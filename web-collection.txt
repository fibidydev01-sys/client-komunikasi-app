================================================
CHAT APP WEB FILES COLLECTION
Generated: Wed, Dec 10, 2025  9:07:58 AM
Base Path: /d/READY-TO-SHIP/project/CHAT-APP/web
================================================

================================================
FILE: src/vite-env.d.ts
================================================

/// <reference types="vite/client" />

// ================================================
// FILE: src/vite-env.d.ts
// Vite Environment Variables Type Definitions
// ================================================

interface ImportMetaEnv {
  readonly VITE_API_URL: string;
  readonly VITE_SOCKET_URL: string;
  readonly VITE_CLOUDINARY_CLOUD_NAME: string;
  readonly VITE_CLOUDINARY_UPLOAD_PRESET: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}

================================================
FILE: src/main.tsx
================================================

// src/main.tsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './app/App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  // ‚ùå DISABLE STRICT MODE (causes double mount in dev)
  // <React.StrictMode>
  <App />
  // </React.StrictMode>
);

================================================
FILE: src/index.css
================================================

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 217.2 91.2% 59.8%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 224.3 76.3% 48%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  @apply bg-background;
}

::-webkit-scrollbar-thumb {
  @apply bg-muted-foreground/20 rounded-full;
}

::-webkit-scrollbar-thumb:hover {
  @apply bg-muted-foreground/30;
}

================================================
FILE: src/app/App.tsx
================================================

// ================================================
// FILE: src/app/App.tsx
// Main App Component (WITH TOASTER)
// ================================================

import { RouterProvider } from 'react-router-dom';
import { Toaster } from 'sonner'; // ‚Üê ADDED
import { AppProviders } from './providers';
import { router } from './routes';

function App() {
  return (
    <AppProviders>
      <RouterProvider router={router} />
      <Toaster
        position="top-right"
        richColors
        closeButton
        duration={3000}
      /> {/* ‚Üê ADDED */}
    </AppProviders>
  );
}

export default App;

================================================
FILE: src/app/providers/auth-provider.tsx
================================================

// ================================================
// FILE: src/app/providers/auth-provider.tsx
// AuthProvider - Initialize authentication
// ================================================

import { useEffect, ReactNode } from 'react';
import { useAuthStore } from '@/features/auth/store/auth.store';
import { LoadingPage } from '@/shared/components/common/loading-spinner';

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider = ({ children }: AuthProviderProps) => {
  const { checkAuth, isLoading } = useAuthStore();

  // FIXED: Only run once on mount, no dependencies
  useEffect(() => {
    console.log('üîê AuthProvider: Initial auth check...');
    checkAuth();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // ‚Üê Empty array = run once only!

  if (isLoading) {
    return <LoadingPage text="Loading..." />;
  }

  return <>{children}</>;
};

================================================
FILE: src/app/providers/index.tsx
================================================

// ================================================
// FILE: src/app/providers/index.tsx
// Combined Providers - All providers in one
// ================================================

import { ReactNode } from 'react';
import { ThemeProvider } from './theme-provider';
import { AuthProvider } from './auth-provider';
import { SocketProvider } from './socket-provider';
import { ErrorBoundary } from '@/shared/components/common/error-boundary';

interface AppProvidersProps {
  children: ReactNode;
}

export const AppProviders = ({ children }: AppProvidersProps) => {
  return (
    <ErrorBoundary>
    <ThemeProvider defaultTheme= "system" >
    <AuthProvider>
    <SocketProvider>
    { children }
    </SocketProvider>
    </AuthProvider>
    </ThemeProvider>
    </ErrorBoundary>
  );
};

// Re-export individual providers
export { ThemeProvider, useTheme } from './theme-provider';
export { AuthProvider } from './auth-provider';
export { SocketProvider } from './socket-provider';

================================================
FILE: src/app/providers/socket-provider.tsx
================================================

// ================================================
// FILE: src/app/providers/socket-provider.tsx
// SocketProvider - Handle socket & ALL listeners (FIXED)
// ================================================

import { useEffect, useRef, ReactNode } from 'react';
// ‚ùå HAPUS: import { useNavigate } from 'react-router-dom';
import { socketClient } from '@/lib/socket-client';
import { useAuthStore } from '@/features/auth/store/auth.store';
import { useChatStore } from '@/features/chat/store/chat.store';
import { useCallStore } from '@/features/call/store/call.store';
import { authService } from '@/features/auth/services/auth.service';
import { SOCKET_EVENTS } from '@/shared/constants/socket-events';
// ‚ùå HAPUS: import { ROUTE_PATHS } from '@/shared/constants/route-paths';
import { toastHelper } from '@/shared/utils/toast-helper';
import { logger } from '@/shared/utils/logger';
import type { MessageWithDetails } from '@/features/chat/types/chat.types';
import type { CallWithDetails } from '@/features/call/types/call.types';

interface SocketProviderProps {
  children: ReactNode;
}

export const SocketProvider = ({ children }: SocketProviderProps) => {
  // ‚ùå HAPUS: const navigate = useNavigate();
  const { isAuthenticated } = useAuthStore();
  const { addMessage, setTyping } = useChatStore();
  const {
    setIncomingCall,
    setActiveCall,
    cleanupStreams,
    activeCall
  } = useCallStore();

  const hasConnected = useRef(false);
  const ringtoneRef = useRef<HTMLAudioElement | null>(null);

  useEffect(() => {
    if (isAuthenticated && !hasConnected.current && !socketClient.isConnected()) {
      const token = authService.getToken();

      if (!token) {
        logger.warn('Socket Provider: No token found, skipping connection');
        return;
      }

      try {
        hasConnected.current = true;
        logger.debug('Socket Provider: Connecting to socket...');

        socketClient.connect(token);

        logger.success('Socket Provider: ‚úÖ Socket connected');

        // ============================================
        // CHAT LISTENERS
        // ============================================
        const handleMessageReceive = (message: MessageWithDetails) => {
          logger.debug('Socket: üí¨ Message received:', message.id);
          addMessage(message);
        };

        const handleTypingStart = (data: { userId: string; chatId: string }) => {
          logger.debug('Socket: ‚å®Ô∏è Typing start:', data);
          setTyping(data.chatId, data.userId, true);
        };

        const handleTypingStop = (data: { userId: string; chatId: string }) => {
          logger.debug('Socket: ‚å®Ô∏è Typing stop:', data);
          setTyping(data.chatId, data.userId, false);
        };

        // ============================================
        // CALL LISTENERS
        // ============================================
        const handleIncomingCall = (data: { call: CallWithDetails }) => {
          logger.info('Socket: üìû INCOMING CALL from:', data.call.caller.name);

          setIncomingCall(data.call);
          toastHelper.info(`üìû Incoming call from ${data.call.caller.name}`);

          // Play ringtone
          try {
            ringtoneRef.current = new Audio('/sounds/ringtone.mp3');
            ringtoneRef.current.loop = true;
            ringtoneRef.current.volume = 0.5;
            ringtoneRef.current.play().catch(() => {
              logger.warn('Socket: Ringtone autoplay blocked');
            });
          } catch (e) {
            logger.warn('Socket: Failed to load ringtone');
          }

          // Browser notification
          if ('Notification' in window && Notification.permission === 'granted') {
            const notification = new Notification('Incoming Call', {
              body: `${data.call.caller.name} is calling you`,
              icon: data.call.caller.avatar || '/phone-icon.png',
              tag: 'incoming-call',
              requireInteraction: true,
            });

            notification.onclick = () => {
              window.focus();
              notification.close();
            };
          }
        };

        const handleCallAnswered = (data: { call: CallWithDetails }) => {
          logger.success('Socket: ‚úÖ Call ANSWERED by:', data.call.receiver.name);

          // Stop ringtone
          if (ringtoneRef.current) {
            ringtoneRef.current.pause();
            ringtoneRef.current.currentTime = 0;
            ringtoneRef.current = null;
          }

          setActiveCall(data.call);
          setIncomingCall(null);
          toastHelper.success(`${data.call.receiver.name} answered the call`);
        };

        const handleCallRejected = (data: { call: CallWithDetails }) => {
          logger.info('Socket: ‚ùå Call REJECTED by:', data.call.receiver.name);

          // Stop ringtone
          if (ringtoneRef.current) {
            ringtoneRef.current.pause();
            ringtoneRef.current.currentTime = 0;
            ringtoneRef.current = null;
          }

          cleanupStreams();
          setIncomingCall(null);
          setActiveCall(null);
          toastHelper.warning(`${data.call.receiver.name} declined the call`);
          // ‚ùå HAPUS: navigate(ROUTE_PATHS.CALLS);
          // ‚úÖ Navigation akan di-handle oleh component yang listen ke activeCall
        };

        const handleCallEnded = (data: { call: CallWithDetails }) => {
          logger.info('Socket: üìû Call ENDED:', data.call.id);

          // Stop ringtone
          if (ringtoneRef.current) {
            ringtoneRef.current.pause();
            ringtoneRef.current.currentTime = 0;
            ringtoneRef.current = null;
          }

          cleanupStreams();
          setActiveCall(null);
          setIncomingCall(null);
          toastHelper.info('Call ended');
          // ‚ùå HAPUS: navigate(ROUTE_PATHS.CALLS);
          // ‚úÖ Navigation akan di-handle oleh component yang listen ke activeCall
        };

        // ============================================
        // REGISTER ALL LISTENERS
        // ============================================

        // Chat listeners
        socketClient.on(SOCKET_EVENTS.MESSAGE_RECEIVE, handleMessageReceive);
        socketClient.on(SOCKET_EVENTS.TYPING_START, handleTypingStart);
        socketClient.on(SOCKET_EVENTS.TYPING_STOP, handleTypingStop);

        // Call listeners
        socketClient.on(SOCKET_EVENTS.CALL_INCOMING, handleIncomingCall);
        socketClient.on(SOCKET_EVENTS.CALL_ANSWERED, handleCallAnswered);
        socketClient.on(SOCKET_EVENTS.CALL_REJECTED, handleCallRejected);
        socketClient.on(SOCKET_EVENTS.CALL_ENDED, handleCallEnded);

        logger.success('Socket Provider: ‚úÖ All listeners registered');

      } catch (error) {
        logger.error('Socket Provider: Socket connection failed:', error);
        toastHelper.error('Failed to connect to server');
        hasConnected.current = false;
      }
    }

    // Cleanup on logout
    return () => {
      if (!isAuthenticated && hasConnected.current) {
        logger.debug('Socket Provider: User logged out, disconnecting socket');

        // Remove all listeners
        socketClient.off(SOCKET_EVENTS.MESSAGE_RECEIVE);
        socketClient.off(SOCKET_EVENTS.TYPING_START);
        socketClient.off(SOCKET_EVENTS.TYPING_STOP);
        socketClient.off(SOCKET_EVENTS.CALL_INCOMING);
        socketClient.off(SOCKET_EVENTS.CALL_ANSWERED);
        socketClient.off(SOCKET_EVENTS.CALL_REJECTED);
        socketClient.off(SOCKET_EVENTS.CALL_ENDED);

        // Stop ringtone
        if (ringtoneRef.current) {
          ringtoneRef.current.pause();
          ringtoneRef.current = null;
        }

        socketClient.disconnect();
        hasConnected.current = false;
      }
    };
  }, [
    isAuthenticated,
    addMessage,
    setTyping,
    setIncomingCall,
    setActiveCall,
    cleanupStreams,
    activeCall,
    // ‚ùå HAPUS: navigate dari dependencies
  ]);

  // Request notification permission on mount
  useEffect(() => {
    if ('Notification' in window && Notification.permission === 'default') {
      Notification.requestPermission();
    }
  }, []);

  return <>{children}</>;
};

================================================
FILE: src/app/providers/theme-provider.tsx
================================================

// ================================================
// FILE: src/app/providers/theme-provider.tsx
// ThemeProvider - Theme management (Light/Dark mode)
// ================================================

import { createContext, useContext, useEffect, useState, ReactNode } from 'react';

type Theme = 'light' | 'dark' | 'system';

interface ThemeContextType {
  theme: Theme;
  setTheme: (theme: Theme) => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
};

interface ThemeProviderProps {
  children: ReactNode;
  defaultTheme?: Theme;
  storageKey?: string;
}

export const ThemeProvider = ({
  children,
  defaultTheme = 'system',
  storageKey = 'chat-app-theme',
}: ThemeProviderProps) => {
  const [theme, setTheme] = useState<Theme>(
    () => (localStorage.getItem(storageKey) as Theme) || defaultTheme
  );

  useEffect(() => {
    const root = window.document.documentElement;
    root.classList.remove('light', 'dark');

    if (theme === 'system') {
      const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches
        ? 'dark'
        : 'light';
      root.classList.add(systemTheme);
    } else {
      root.classList.add(theme);
    }
  }, [theme]);

  const value = {
    theme,
    setTheme: (newTheme: Theme) => {
      localStorage.setItem(storageKey, newTheme);
      setTheme(newTheme);
    },
  };

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
};

================================================
FILE: src/app/routes/index.tsx
================================================

// ================================================
// FILE: src/app/routes/index.tsx
// Main Application Router (WITHOUT ACTIVE CALL ROUTE - USING MODAL INSTEAD)
// ================================================

import { createBrowserRouter, Navigate } from 'react-router-dom';
import { ProtectedRoute } from './protected-route';
import { PublicRoute } from './public-route';
import { ROUTE_PATHS } from '@/shared/constants/route-paths';

// Pages
import {
  LoginPage,
  RegisterPage,
  ChatPage,
  CallsPage,
  ContactsPage,
  StatusPage,
  ProfilePage,
} from '@/pages';

export const router = createBrowserRouter([
  {
    path: '/',
    element: <Navigate to={ROUTE_PATHS.CHATS} replace />,
  },

  // Public Routes (Guest only)
  {
    path: ROUTE_PATHS.LOGIN,
    element: (
      <PublicRoute>
        <LoginPage />
      </PublicRoute>
    ),
  },
  {
    path: ROUTE_PATHS.REGISTER,
    element: (
      <PublicRoute>
        <RegisterPage />
      </PublicRoute>
    ),
  },

  // Protected Routes (Authenticated only)
  {
    path: ROUTE_PATHS.CHATS,
    element: (
      <ProtectedRoute>
        <ChatPage />
      </ProtectedRoute>
    ),
  },
  {
    path: '/chats/:chatId',
    element: (
      <ProtectedRoute>
        <ChatPage />
      </ProtectedRoute>
    ),
  },
  {
    path: ROUTE_PATHS.CALLS,
    element: (
      <ProtectedRoute>
        <CallsPage />
      </ProtectedRoute>
    ),
  },
  // ‚ùå REMOVED: Active Call Route (now using modal instead)
  // {
  //   path: ROUTE_PATHS.ACTIVE_CALL,
  //   element: (
  //     <ProtectedRoute>
  //       <ActiveCallPage />
  //     </ProtectedRoute>
  //   ),
  // },
  {
    path: ROUTE_PATHS.CONTACTS,
    element: (
      <ProtectedRoute>
        <ContactsPage />
      </ProtectedRoute>
    ),
  },
  {
    path: ROUTE_PATHS.STATUS,
    element: (
      <ProtectedRoute>
        <StatusPage />
      </ProtectedRoute>
    ),
  },
  {
    path: ROUTE_PATHS.PROFILE,
    element: (
      <ProtectedRoute>
        <ProfilePage />
      </ProtectedRoute>
    ),
  },

  // 404 - Not Found
  {
    path: '*',
    element: (
      <div className="flex min-h-screen items-center justify-center">
        <div className="text-center">
          <h1 className="text-4xl font-bold mb-2">404</h1>
          <p className="text-muted-foreground mb-4">Page not found</p>
          <a href="/" className="text-primary hover:underline">
            Go back home
          </a>
        </div>
      </div>
    ),
  },
]);

================================================
FILE: src/app/routes/protected-route.tsx
================================================

// ================================================
// FILE: src/app/routes/protected-route.tsx
// ProtectedRoute - Require authentication
// ================================================

import { ReactNode } from 'react';
import { Navigate } from 'react-router-dom';
import { useAuthStore } from '@/features/auth/store/auth.store';
import { LoadingPage } from '@/shared/components/common/loading-spinner';
import { ROUTE_PATHS } from '@/shared/constants/route-paths';

interface ProtectedRouteProps {
  children: ReactNode;
}

export const ProtectedRoute = ({ children }: ProtectedRouteProps) => {
  const { isAuthenticated, isLoading } = useAuthStore();

  if (isLoading) {
    return <LoadingPage text="Checking authentication..." />;
  }

  if (!isAuthenticated) {
    return <Navigate to={ROUTE_PATHS.LOGIN} replace />;
  }

  return <>{children}</>;
};

================================================
FILE: src/app/routes/public-route.tsx
================================================

// ================================================
// FILE: src/app/routes/public-route.tsx
// PublicRoute - Redirect if authenticated
// ================================================

import { ReactNode } from 'react';
import { Navigate } from 'react-router-dom';
import { useAuthStore } from '@/features/auth/store/auth.store';
import { ROUTE_PATHS } from '@/shared/constants/route-paths';

interface PublicRouteProps {
  children: ReactNode;
}

export const PublicRoute = ({ children }: PublicRouteProps) => {
  const { isAuthenticated } = useAuthStore();

  if (isAuthenticated) {
    return <Navigate to={ROUTE_PATHS.CHATS} replace />;
  }

  return <>{children}</>;
};

================================================
FILE: src/features/auth/hooks/use-auth.ts
================================================

// ================================================
// FILE 3: src/features/auth/hooks/use-auth.ts
// FIX: Add proper delay before navigation
// ================================================

import { useNavigate } from 'react-router-dom';
import { useAuthStore } from '../store/auth.store';
import { ROUTE_PATHS } from '@/shared/constants/route-paths';
import { logger } from '@/shared/utils/logger';
import type { LoginInput, RegisterInput } from '../types/auth.types';

export const useAuth = () => {
  const navigate = useNavigate();
  const {
    user,
    isAuthenticated,
    isLoading,
    error,
    login,
    register,
    logout,
    checkAuth,
    clearError,
  } = useAuthStore();

  // Login handler
  const handleLogin = async (data: LoginInput) => {
    try {
      await login(data);

      // ‚úÖ CRITICAL FIX: Wait longer to ensure token is readable
      await new Promise(resolve => setTimeout(resolve, 200));

      // ‚úÖ VERIFY token exists before navigation
      const token = localStorage.getItem('access_token');
      if (!token) {
        logger.error('useAuth: Token not found after login!');
        throw new Error('Authentication failed - token not saved');
      }

      logger.debug('useAuth: Token verified before navigation:', token.substring(0, 20));

      navigate(ROUTE_PATHS.CHATS, { replace: true });
      logger.success('Login successful, navigated to chats');
    } catch (error) {
      logger.error('Login failed:', error);
      throw error;
    }
  };

  // Register handler
  const handleRegister = async (data: RegisterInput) => {
    try {
      await register(data);

      // ‚úÖ CRITICAL FIX: Wait longer to ensure token is readable
      await new Promise(resolve => setTimeout(resolve, 200));

      // ‚úÖ VERIFY token exists before navigation
      const token = localStorage.getItem('access_token');
      if (!token) {
        logger.error('useAuth: Token not found after register!');
        throw new Error('Authentication failed - token not saved');
      }

      logger.debug('useAuth: Token verified before navigation:', token.substring(0, 20));

      navigate(ROUTE_PATHS.CHATS, { replace: true });
      logger.success('Registration successful, navigated to chats');
    } catch (error) {
      logger.error('Registration failed:', error);
      throw error;
    }
  };

  // Logout handler
  const handleLogout = async () => {
    try {
      await logout();
      navigate(ROUTE_PATHS.LOGIN, { replace: true });
      logger.success('Logout successful, redirecting to login...');
    } catch (error) {
      logger.error('Logout failed:', error);
    }
  };

  return {
    user,
    isAuthenticated,
    isLoading,
    error,
    login: handleLogin,
    register: handleRegister,
    logout: handleLogout,
    clearError,
  };
};

================================================
FILE: src/features/auth/pages/login-page.tsx
================================================

// ================================================
// FILE: src/features/auth/pages/login-page.tsx
// LoginPage - User login page (CLEANED)
// ================================================

import { useState, FormEvent, useEffect } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { AuthLayout } from '@/shared/components/layouts/auth-layout';
import { Button } from '@/shared/components/ui/button';
import { Input } from '@/shared/components/ui/input';
import { Label } from '@/shared/components/ui/label';
import { useAuth } from '../hooks/use-auth';
import { ROUTE_PATHS } from '@/shared/constants/route-paths';
import { Loader2 } from 'lucide-react';

export const LoginPage = () => {
  const navigate = useNavigate();
  const { login, isLoading, error, isAuthenticated } = useAuth();
  const [formData, setFormData] = useState({
    email: '',
    password: '',
  });

  // Auto redirect when authenticated
  useEffect(() => {
    if (isAuthenticated) {
      navigate(ROUTE_PATHS.CHATS, { replace: true });
    }
  }, [isAuthenticated, navigate]);

  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    try {
      await login(formData);
    } catch (error) {
      // Error handled by store (toast shown)
    }
  };

  return (
    <AuthLayout
      title="Welcome Back"
      subtitle="Sign in to your account to continue"
    >
      <form onSubmit={handleSubmit} className="space-y-4">
        {error && (
          <div className="rounded-lg bg-destructive/10 p-3 text-sm text-destructive">
            {error}
          </div>
        )}

        <div className="space-y-2">
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            placeholder="Enter your email"
            value={formData.email}
            onChange={(e) => setFormData({ ...formData, email: e.target.value })}
            required
            disabled={isLoading}
          />
        </div>

        <div className="space-y-2">
          <Label htmlFor="password">Password</Label>
          <Input
            id="password"
            type="password"
            placeholder="Enter your password"
            value={formData.password}
            onChange={(e) => setFormData({ ...formData, password: e.target.value })}
            required
            disabled={isLoading}
          />
        </div>

        <Button
          type="submit"
          className="w-full"
          disabled={isLoading}
        >
          {isLoading ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Signing in...
            </>
          ) : (
            'Sign In'
          )}
        </Button>

        <div className="text-center text-sm">
          <span className="text-muted-foreground">Don't have an account? </span>
          <Link
            to={ROUTE_PATHS.REGISTER}
            className="font-medium text-primary hover:underline"
          >
            Sign Up
          </Link>
        </div>
      </form>
    </AuthLayout>
  );
};

================================================
FILE: src/features/auth/pages/register-page.tsx
================================================

// ================================================
// FILE: src/features/auth/pages/register-page.tsx
// RegisterPage - User registration page (CLEANED)
// ================================================

import { useState, FormEvent } from 'react';
import { Link } from 'react-router-dom';
import { AuthLayout } from '@/shared/components/layouts/auth-layout';
import { Button } from '@/shared/components/ui/button';
import { Input } from '@/shared/components/ui/input';
import { Label } from '@/shared/components/ui/label';
import { useAuth } from '../hooks/use-auth';
import { ROUTE_PATHS } from '@/shared/constants/route-paths';
import { Loader2 } from 'lucide-react';

export const RegisterPage = () => {
  const { register, isLoading, error } = useAuth();
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: '',
    username: '',
  });

  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    try {
      await register(formData);
    } catch (error) {
      // Error handled by store (toast shown)
    }
  };

  return (
    <AuthLayout
      title="Create Account"
      subtitle="Sign up to get started"
    >
      <form onSubmit={handleSubmit} className="space-y-4">
        {error && (
          <div className="rounded-lg bg-destructive/10 p-3 text-sm text-destructive">
            {error}
          </div>
        )}

        <div className="space-y-2">
          <Label htmlFor="name">Full Name</Label>
          <Input
            id="name"
            type="text"
            placeholder="Enter your name"
            value={formData.name}
            onChange={(e) => setFormData({ ...formData, name: e.target.value })}
            required
            disabled={isLoading}
          />
        </div>

        <div className="space-y-2">
          <Label htmlFor="username">Username (optional)</Label>
          <Input
            id="username"
            type="text"
            placeholder="Choose a username"
            value={formData.username}
            onChange={(e) => setFormData({ ...formData, username: e.target.value })}
            disabled={isLoading}
          />
        </div>

        <div className="space-y-2">
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            placeholder="Enter your email"
            value={formData.email}
            onChange={(e) => setFormData({ ...formData, email: e.target.value })}
            required
            disabled={isLoading}
          />
        </div>

        <div className="space-y-2">
          <Label htmlFor="password">Password</Label>
          <Input
            id="password"
            type="password"
            placeholder="Create a password (min. 6 characters)"
            value={formData.password}
            onChange={(e) => setFormData({ ...formData, password: e.target.value })}
            required
            minLength={6}
            disabled={isLoading}
          />
        </div>

        <Button
          type="submit"
          className="w-full"
          disabled={isLoading}
        >
          {isLoading ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Creating account...
            </>
          ) : (
            'Sign Up'
          )}
        </Button>

        <div className="text-center text-sm">
          <span className="text-muted-foreground">Already have an account? </span>
          <Link
            to={ROUTE_PATHS.LOGIN}
            className="font-medium text-primary hover:underline"
          >
            Sign In
          </Link>
        </div>
      </form>
    </AuthLayout>
  );
};

================================================
FILE: src/features/auth/services/auth.service.ts
================================================

// ================================================
// FILE 1: src/features/auth/services/auth.service.ts
// FIX: Ensure token is written BEFORE returning
// ================================================

import { axiosClient } from '@/lib/axios-client';
import { API_ENDPOINTS } from '@/shared/constants/api-endpoints';
import { logger } from '@/shared/utils/logger';
import type { ApiResponse } from '@/shared/types/api-types';
import type { User } from '@/shared/types/user-types';
import type {
  LoginInput,
  RegisterInput,
  AuthResponse
} from '../types/auth.types';

export const authService = {
  // Register new user
  register: async (data: RegisterInput): Promise<AuthResponse> => {
    logger.debug('Auth Service: Registering user...');
    const response = await axiosClient.post<AuthResponse>(
      API_ENDPOINTS.AUTH.REGISTER,
      data
    );

    logger.debug('Auth Service: Register response received');

    // ‚úÖ FIX: Save token SYNCHRONOUSLY and VERIFY
    if (response.data.accessToken) {
      localStorage.setItem('access_token', response.data.accessToken);

      // ‚úÖ CRITICAL: Force sync and verify
      const verified = localStorage.getItem('access_token');
      if (!verified) {
        throw new Error('Failed to save token to localStorage');
      }

      logger.debug('Auth Service: Token saved and verified');
    }

    return response.data;
  },

  // Login user
  login: async (data: LoginInput): Promise<AuthResponse> => {
    logger.debug('Auth Service: Logging in user...');
    const response = await axiosClient.post<AuthResponse>(
      API_ENDPOINTS.AUTH.LOGIN,
      data
    );

    logger.debug('Auth Service: Login response received');

    // ‚úÖ FIX: Save token SYNCHRONOUSLY and VERIFY
    if (response.data.accessToken) {
      localStorage.setItem('access_token', response.data.accessToken);

      // ‚úÖ CRITICAL: Force sync and verify
      const verified = localStorage.getItem('access_token');
      if (!verified) {
        throw new Error('Failed to save token to localStorage');
      }

      logger.debug('Auth Service: Token saved and verified:', verified.substring(0, 20));
    }

    return response.data;
  },

  // Logout user
  logout: async (): Promise<void> => {
    logger.debug('Auth Service: Logging out...');
    try {
      await axiosClient.post(API_ENDPOINTS.AUTH.LOGOUT);
      logger.success('Auth Service: Logout API success');
    } catch (error) {
      logger.warn('Auth Service: Logout API failed:', error);
    } finally {
      // Always clear token, even if API fails
      localStorage.removeItem('access_token');
      logger.debug('Auth Service: Token removed from localStorage');
    }
  },

  // Get auth status (verify token)
  getAuthStatus: async (): Promise<User> => {
    logger.debug('Auth Service: Checking auth status...');
    const response = await axiosClient.get<any>(
      API_ENDPOINTS.AUTH.STATUS
    );

    logger.success('Auth Service: Auth status verified');

    // Backend returns { message, user } directly
    return response.data.user;
  },

  // Check if user is authenticated
  isAuthenticated: (): boolean => {
    const hasToken = !!localStorage.getItem('access_token');
    logger.debug('Auth Service: Is authenticated?', hasToken);
    return hasToken;
  },

  // Get stored token
  getToken: (): string | null => {
    return localStorage.getItem('access_token');
  },
};

================================================
FILE: src/features/auth/store/auth.store.ts
================================================

// ================================================
// FILE 2: src/features/auth/store/auth.store.ts
// FIX: Add delay AFTER token save to ensure it's readable
// ================================================

import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { authService } from '../services/auth.service';
import { resetChatFetch } from '@/features/chat/hooks/use-chat';
import { resetContactsFetch } from '@/features/contacts/hooks/use-contacts';
import { resetStatusFetch } from '@/features/status/hooks/use-status';
import { resetCallFetch } from '@/features/call/hooks/use-call';
import { toastHelper } from '@/shared/utils/toast-helper';
import { logger } from '@/shared/utils/logger';
import type { User } from '@/shared/types/user-types';
import type { LoginInput, RegisterInput } from '../types/auth.types';

interface AuthState {
  // State
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;

  // Actions
  login: (data: LoginInput) => Promise<void>;
  register: (data: RegisterInput) => Promise<void>;
  logout: () => Promise<void>;
  checkAuth: () => Promise<void>;
  setUser: (user: User | null) => void;
  clearError: () => void;
}

// ‚úÖ ADD: Helper to wait for localStorage sync
const waitForLocalStorage = (key: string, maxAttempts = 5): Promise<string | null> => {
  return new Promise((resolve) => {
    let attempts = 0;

    const check = () => {
      const value = localStorage.getItem(key);

      if (value || attempts >= maxAttempts) {
        resolve(value);
        return;
      }

      attempts++;
      setTimeout(check, 10); // Check every 10ms
    };

    check();
  });
};

export const useAuthStore = create<AuthState>()(
  devtools(
    persist(
      (set) => ({
        // Initial state
        user: null,
        isAuthenticated: false,
        isLoading: false,
        error: null,

        // Login
        login: async (data) => {
          set({ isLoading: true, error: null });

          const loadingToast = toastHelper.loading('Signing in...');

          try {
            logger.debug('Auth Store: Starting login...');
            const response = await authService.login(data);

            // ‚úÖ CRITICAL FIX: Wait for token to be readable
            const token = await waitForLocalStorage('access_token');

            if (!token) {
              throw new Error('Token not saved properly');
            }

            logger.debug('Auth Store: Token verified after save:', token.substring(0, 20));

            toastHelper.dismiss(loadingToast);
            toastHelper.success('Signed in successfully!');

            set({
              user: response.user,
              isAuthenticated: true,
              isLoading: false
            });

            logger.success('Auth Store: Login successful');
          } catch (error: any) {
            toastHelper.dismiss(loadingToast);

            const errorMsg = error.response?.data?.message || error.message || 'Login failed';
            toastHelper.error(errorMsg);

            logger.error('Auth Store: Login failed:', error);

            set({
              error: errorMsg,
              isLoading: false
            });
            throw error;
          }
        },

        // Register
        register: async (data) => {
          set({ isLoading: true, error: null });

          const loadingToast = toastHelper.loading('Creating your account...');

          try {
            logger.debug('Auth Store: Starting registration...');
            const response = await authService.register(data);

            // ‚úÖ CRITICAL FIX: Wait for token to be readable
            const token = await waitForLocalStorage('access_token');

            if (!token) {
              throw new Error('Token not saved properly');
            }

            logger.debug('Auth Store: Token verified after save:', token.substring(0, 20));

            toastHelper.dismiss(loadingToast);
            toastHelper.success('Account created successfully!');

            set({
              user: response.user,
              isAuthenticated: true,
              isLoading: false
            });

            logger.success('Auth Store: Registration successful');
          } catch (error: any) {
            toastHelper.dismiss(loadingToast);

            const errorMsg = error.response?.data?.message || error.message || 'Registration failed';
            toastHelper.error(errorMsg);

            logger.error('Auth Store: Registration failed:', error);

            set({
              error: errorMsg,
              isLoading: false
            });
            throw error;
          }
        },

        // Logout
        logout: async () => {
          set({ isLoading: true });

          try {
            logger.debug('Auth Store: Logging out...');
            await authService.logout();

            // ‚úÖ Reset all fetch flags (INCLUDING CALL)
            resetChatFetch();
            resetContactsFetch();
            resetStatusFetch();
            resetCallFetch();

            toastHelper.success('Signed out successfully');

            set({
              user: null,
              isAuthenticated: false,
              isLoading: false,
              error: null
            });

            logger.success('Auth Store: Logout successful');
          } catch (error) {
            logger.warn('Auth Store: Logout API failed, clearing state anyway');

            // ‚úÖ Reset all fetch flags even on error
            resetChatFetch();
            resetContactsFetch();
            resetStatusFetch();
            resetCallFetch();

            // Force logout even if API fails
            set({
              user: null,
              isAuthenticated: false,
              isLoading: false,
              error: null
            });
          }
        },

        // Check authentication status
        checkAuth: async () => {
          if (!authService.isAuthenticated()) {
            logger.debug('Auth Store: No token found');
            set({ user: null, isAuthenticated: false });
            return;
          }

          set({ isLoading: true });
          try {
            logger.debug('Auth Store: Checking auth status...');
            const user = await authService.getAuthStatus();

            set({
              user,
              isAuthenticated: true,
              isLoading: false
            });

            logger.success('Auth Store: Auth check successful');
          } catch (error) {
            logger.error('Auth Store: Auth check failed:', error);
            set({
              user: null,
              isAuthenticated: false,
              isLoading: false
            });
          }
        },

        // Set user manually
        setUser: (user) => {
          logger.debug('Auth Store: Setting user manually:', user?.name);
          set({ user, isAuthenticated: !!user });
        },

        // Clear error
        clearError: () => {
          set({ error: null });
        },
      }),
      {
        name: 'auth-storage',
        partialize: (state) => ({
          user: state.user,
          isAuthenticated: state.isAuthenticated
        }),
      }
    ),
    { name: 'AuthStore' }
  )
);


================================================
FILE: src/features/auth/types/auth.types.ts
================================================

// ================================================
// FILE: src/features/auth/types/auth.types.ts
// Auth Types - Authentication related types
// ================================================

import type { User } from '@/shared/types/user-types';

// Login Input
export interface LoginInput {
  email: string;
  password: string;
}

// Register Input
export interface RegisterInput {
  name: string;
  email: string;
  password: string;
  username?: string;
  avatar?: string;
}

// Auth Response
export interface AuthResponse {
  message: string;
  user: User;
  accessToken: string;
}

// Auth State
export interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
}

================================================
FILE: src/features/call/components/index.ts
================================================

// ================================================
// FILE: src/features/call/components/index.ts
// Export call components
// ================================================

export { CallButton } from './call-button';
export { IncomingCallModal } from './incoming-call-modal';
export { CallControls } from './call-controls';
export { CallHistoryItem } from './call-history-item';


================================================
FILE: src/features/call/components/active-call-modal.tsx
================================================

// ================================================
// FILE: src/features/call/components/active-call-modal.tsx
// FIXED V3: Added audio element for voice calls
// ================================================

import { useEffect, useState, useRef, useCallback } from 'react';
import {
  PhoneOff,
  Mic,
  MicOff,
  Video,
  VideoOff,
  AlertCircle,
  Loader2,
  Volume2,
  VolumeX
} from 'lucide-react';
import { Button } from '@/shared/components/ui/button';
import { UserAvatar } from '@/shared/components/common/user-avatar';
import { useCallStore } from '../store/call.store';
import { useWebRTC } from '../hooks/use-webrtc';
import { useAuthStore } from '@/features/auth/store/auth.store';
import { logger } from '@/shared/utils/logger';

interface ActiveCallModalProps {
  open: boolean;
  onClose: () => void;
}

export const ActiveCallModal = ({ open, onClose }: ActiveCallModalProps) => {
  const { user } = useAuthStore();
  const {
    activeCall,
    endCall,
    isMuted,
    isVideoEnabled,
    toggleMute,
    toggleVideo,
    localStream,
    remoteStream,
    isConnected,
    connectionState,
    cleanupStreams,
    isEnding,
  } = useCallStore();

  const [callDuration, setCallDuration] = useState(0);
  const [isInitializing, setIsInitializing] = useState(false);
  const [audioPlaying, setAudioPlaying] = useState(false);

  const localVideoRef = useRef<HTMLVideoElement | null>(null);
  const remoteVideoRef = useRef<HTMLVideoElement | null>(null);
  const remoteAudioRef = useRef<HTMLAudioElement | null>(null); // ‚úÖ Audio element for voice calls
  const callTimerRef = useRef<NodeJS.Timeout | null>(null);
  const callStartTimeRef = useRef<number | null>(null);
  const webrtcCleanupRef = useRef<(() => void) | null>(null);
  const hasInitializedRef = useRef(false);

  // Determine call details
  const isCaller = activeCall?.callerId === user?.id;
  const otherParticipant = isCaller ? activeCall?.receiver : activeCall?.caller;
  const isVideoCall = activeCall?.type === 'VIDEO';

  // Initialize WebRTC hook
  const { initializeCall, cleanup, isInitialized, mediaError } = useWebRTC({
    callId: activeCall?.id || '',
    otherUserId: otherParticipant?.id || '',
    isCaller,
    isVideoCall: isVideoCall || false,
  });

  // Store cleanup reference
  useEffect(() => {
    webrtcCleanupRef.current = cleanup;
  }, [cleanup]);

  // ‚úÖ Initialize WebRTC when modal opens - BOTH caller and receiver
  useEffect(() => {
    if (open && activeCall && !hasInitializedRef.current && !isInitialized) {
      hasInitializedRef.current = true;
      setIsInitializing(true);

      logger.debug('Active Call Modal: Initializing WebRTC...', {
        isCaller,
        callId: activeCall.id,
        status: activeCall.status,
      });

      initializeCall().finally(() => {
        setIsInitializing(false);
      });
    }
  }, [open, activeCall, isInitialized, initializeCall, isCaller]);

  // Reset hasInitialized when modal closes
  useEffect(() => {
    if (!open) {
      hasInitializedRef.current = false;
    }
  }, [open]);

  // Attach local stream to video element
  useEffect(() => {
    if (localStream && localVideoRef.current) {
      localVideoRef.current.srcObject = localStream;
      logger.debug('Active Call Modal: Local stream attached');
    }
  }, [localStream]);

  // ‚úÖ CRITICAL: Attach remote stream to BOTH video AND audio elements
  useEffect(() => {
    if (remoteStream) {
      logger.debug('Active Call Modal: Remote stream received', {
        audioTracks: remoteStream.getAudioTracks().length,
        videoTracks: remoteStream.getVideoTracks().length,
      });

      // For video calls - attach to video element
      if (remoteVideoRef.current) {
        remoteVideoRef.current.srcObject = remoteStream;
        logger.debug('Active Call Modal: Remote stream attached to video element');
      }

      // ‚úÖ For ALL calls (including voice) - attach to audio element
      if (remoteAudioRef.current) {
        remoteAudioRef.current.srcObject = remoteStream;

        // Force play audio
        remoteAudioRef.current.play()
          .then(() => {
            setAudioPlaying(true);
            logger.success('Active Call Modal: ‚úÖ Remote audio playing!');
          })
          .catch((err) => {
            logger.error('Active Call Modal: ‚ùå Failed to play remote audio:', err);
            setAudioPlaying(false);
          });
      }
    }
  }, [remoteStream]);

  // Call duration timer - start when connected
  useEffect(() => {
    if (isConnected && !callStartTimeRef.current) {
      callStartTimeRef.current = Date.now();
      logger.debug('Active Call Modal: Starting call timer');

      callTimerRef.current = setInterval(() => {
        if (callStartTimeRef.current) {
          const elapsed = Math.floor((Date.now() - callStartTimeRef.current) / 1000);
          setCallDuration(elapsed);
        }
      }, 1000);
    }

    return () => {
      if (callTimerRef.current) {
        clearInterval(callTimerRef.current);
        callTimerRef.current = null;
      }
    };
  }, [isConnected]);

  // Format duration
  const formatDuration = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  // Get connection status text
  const getConnectionStatus = () => {
    if (isInitializing) {
      return 'üì° Initializing...';
    }

    if (isConnected) {
      return formatDuration(callDuration);
    }

    switch (connectionState) {
      case 'connecting':
        return 'üìû Connecting...';
      case 'new':
        return 'üìû Starting call...';
      case 'failed':
        return '‚ùå Connection failed';
      case 'disconnected':
        return '‚ö†Ô∏è Reconnecting...';
      default:
        return isCaller ? 'üìû Calling...' : 'üìû Connecting...';
    }
  };

  // Handle end call
  const handleEndCall = useCallback(async () => {
    if (!activeCall || isEnding) {
      logger.warn('Active Call Modal: Cannot end call - no call or already ending');
      return;
    }

    try {
      logger.debug('Active Call Modal: Ending call...');

      // Stop timer
      if (callTimerRef.current) {
        clearInterval(callTimerRef.current);
        callTimerRef.current = null;
      }

      // Calculate duration
      const duration = callStartTimeRef.current
        ? Math.floor((Date.now() - callStartTimeRef.current) / 1000)
        : 0;

      // Cleanup WebRTC
      if (webrtcCleanupRef.current) {
        webrtcCleanupRef.current();
      }
      cleanupStreams();

      // End call on server
      await endCall(activeCall.id, duration);

      // Reset refs
      callStartTimeRef.current = null;
      hasInitializedRef.current = false;
      setCallDuration(0);

      logger.success('Active Call Modal: Call ended');
    } catch (error) {
      logger.error('Active Call Modal: Failed to end call:', error);
    }
  }, [activeCall, isEnding, cleanupStreams, endCall]);

  // Handle external call end
  useEffect(() => {
    if (open && !activeCall) {
      logger.debug('Active Call Modal: Call ended externally');

      if (callTimerRef.current) {
        clearInterval(callTimerRef.current);
        callTimerRef.current = null;
      }

      if (webrtcCleanupRef.current) {
        webrtcCleanupRef.current();
      }

      callStartTimeRef.current = null;
      hasInitializedRef.current = false;
      setCallDuration(0);
    }
  }, [open, activeCall]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (callTimerRef.current) {
        clearInterval(callTimerRef.current);
      }
    };
  }, []);

  if (!open || !activeCall) return null;

  return (
    <div className="fixed inset-0 z-50 bg-gray-900 flex flex-col">
      {/* ‚úÖ CRITICAL: Hidden audio element for remote audio playback */}
      <audio
        ref={remoteAudioRef}
        autoPlay
        playsInline
        style={{ display: 'none' }}
      />

      {/* Header */}
      <div className="absolute top-0 left-0 right-0 z-10 p-4 bg-gradient-to-b from-black/50 to-transparent">
        <div className="flex items-center justify-center flex-col">
          <h2 className="text-xl font-semibold text-white">
            {otherParticipant?.name || 'Unknown'}
          </h2>
          <p className="text-lg text-gray-300 mt-1">
            {getConnectionStatus()}
          </p>

          {/* Audio status indicator */}
          {isConnected && !isVideoCall && (
            <div className="mt-2 flex items-center gap-2">
              {audioPlaying ? (
                <Volume2 className="h-4 w-4 text-green-400" />
              ) : (
                <VolumeX className="h-4 w-4 text-yellow-400" />
              )}
              <span className="text-xs text-gray-400">
                {audioPlaying ? 'Audio active' : 'Waiting for audio...'}
              </span>
            </div>
          )}

          {mediaError && (
            <div className="mt-2 flex items-center gap-2 px-3 py-1 bg-yellow-500/20 rounded-full">
              <AlertCircle className="h-4 w-4 text-yellow-400" />
              <span className="text-sm text-yellow-400">{mediaError}</span>
            </div>
          )}
        </div>
      </div>

      {/* Video/Audio Area */}
      <div className="flex-1 relative">
        {isVideoCall ? (
          <>
            {/* Remote Video (full screen) */}
            <video
              ref={remoteVideoRef}
              autoPlay
              playsInline
              className="w-full h-full object-cover bg-gray-800"
            />

            {/* Local Video (PIP) */}
            <div className="absolute bottom-24 right-4 w-32 h-48 md:w-48 md:h-64 rounded-lg overflow-hidden shadow-lg border-2 border-white/20 bg-gray-700">
              <video
                ref={localVideoRef}
                autoPlay
                playsInline
                muted
                className="w-full h-full object-cover"
                style={{ transform: 'scaleX(-1)' }}
              />

              {!isVideoEnabled && (
                <div className="absolute inset-0 bg-gray-800 flex items-center justify-center">
                  <VideoOff className="h-8 w-8 text-gray-400" />
                </div>
              )}
            </div>

            {/* Waiting for remote video */}
            {!remoteStream && (
              <div className="absolute inset-0 flex items-center justify-center bg-gray-800">
                <div className="text-center">
                  <UserAvatar
                    src={otherParticipant?.avatar}
                    name={otherParticipant?.name || 'Unknown'}
                    size="xl"
                    className="mx-auto mb-4 w-32 h-32"
                  />
                  <p className="text-white text-lg">
                    {isConnected ? 'Camera off' : 'Waiting for video...'}
                  </p>
                  {!isConnected && (
                    <div className="mt-4 flex justify-center">
                      <Loader2 className="h-6 w-6 animate-spin text-white" />
                    </div>
                  )}
                </div>
              </div>
            )}
          </>
        ) : (
          /* Voice Call UI */
          <div className="flex items-center justify-center h-full bg-gradient-to-b from-gray-800 to-gray-900">
            <div className="text-center">
              <div className={`relative ${isConnected ? '' : 'animate-pulse'}`}>
                <UserAvatar
                  src={otherParticipant?.avatar}
                  name={otherParticipant?.name || 'Unknown'}
                  size="xl"
                  className="w-40 h-40 mx-auto"
                />

                {/* Audio wave indicator when connected */}
                {isConnected && audioPlaying && (
                  <div className="absolute -bottom-2 left-1/2 transform -translate-x-1/2">
                    <div className="flex gap-1 items-end">
                      <div className="w-1 bg-green-500 rounded-full animate-pulse" style={{ height: '8px', animationDelay: '0ms' }} />
                      <div className="w-1 bg-green-500 rounded-full animate-pulse" style={{ height: '16px', animationDelay: '100ms' }} />
                      <div className="w-1 bg-green-500 rounded-full animate-pulse" style={{ height: '12px', animationDelay: '200ms' }} />
                      <div className="w-1 bg-green-500 rounded-full animate-pulse" style={{ height: '20px', animationDelay: '300ms' }} />
                      <div className="w-1 bg-green-500 rounded-full animate-pulse" style={{ height: '14px', animationDelay: '400ms' }} />
                      <div className="w-1 bg-green-500 rounded-full animate-pulse" style={{ height: '10px', animationDelay: '500ms' }} />
                    </div>
                  </div>
                )}
              </div>

              <h2 className="text-2xl font-semibold text-white mt-8">
                {otherParticipant?.name || 'Unknown'}
              </h2>

              <p className="text-gray-400 mt-2">
                {isConnected ? 'üé§ Voice Call Connected' : 'üé§ Voice Call'}
              </p>

              {/* Status indicators */}
              <div className="mt-4 flex justify-center gap-4">
                {isMuted && (
                  <div className="flex items-center gap-1 px-2 py-1 bg-red-500/20 rounded-full">
                    <MicOff className="h-3 w-3 text-red-400" />
                    <span className="text-xs text-red-400">Muted</span>
                  </div>
                )}

                {isConnected && !audioPlaying && (
                  <div className="flex items-center gap-1 px-2 py-1 bg-yellow-500/20 rounded-full">
                    <VolumeX className="h-3 w-3 text-yellow-400" />
                    <span className="text-xs text-yellow-400">No audio</span>
                  </div>
                )}
              </div>

              {/* Loading indicator */}
              {!isConnected && (
                <div className="mt-6 flex justify-center">
                  <Loader2 className="h-8 w-8 animate-spin text-blue-500" />
                </div>
              )}
            </div>
          </div>
        )}
      </div>

      {/* Call Controls */}
      <div className="absolute bottom-0 left-0 right-0 p-6 bg-gradient-to-t from-black/80 to-transparent">
        <div className="flex items-center justify-center gap-6">
          {/* Mute */}
          <Button
            size="lg"
            variant={isMuted ? 'destructive' : 'secondary'}
            onClick={toggleMute}
            disabled={isEnding}
            className="h-16 w-16 rounded-full"
            title={isMuted ? 'Unmute' : 'Mute'}
          >
            {isMuted ? <MicOff className="h-7 w-7" /> : <Mic className="h-7 w-7" />}
          </Button>

          {/* Video (only for video calls) */}
          {isVideoCall && (
            <Button
              size="lg"
              variant={!isVideoEnabled ? 'destructive' : 'secondary'}
              onClick={toggleVideo}
              disabled={isEnding}
              className="h-16 w-16 rounded-full"
              title={isVideoEnabled ? 'Turn off camera' : 'Turn on camera'}
            >
              {isVideoEnabled ? <Video className="h-7 w-7" /> : <VideoOff className="h-7 w-7" />}
            </Button>
          )}

          {/* End Call */}
          <Button
            size="lg"
            variant="destructive"
            onClick={handleEndCall}
            disabled={isEnding}
            className="h-16 w-16 rounded-full bg-red-600 hover:bg-red-700"
            title="End call"
          >
            {isEnding ? (
              <Loader2 className="h-7 w-7 animate-spin" />
            ) : (
              <PhoneOff className="h-7 w-7" />
            )}
          </Button>
        </div>

        {/* Connection status */}
        <div className="mt-4 flex justify-center">
          <div className={`flex items-center gap-2 px-3 py-1 rounded-full ${isConnected
              ? 'bg-green-500/20 text-green-400'
              : 'bg-yellow-500/20 text-yellow-400'
            }`}>
            <div className={`w-2 h-2 rounded-full ${isConnected
                ? 'bg-green-500'
                : 'bg-yellow-500 animate-pulse'
              }`} />
            <span className="text-sm">
              {isEnding
                ? 'Ending...'
                : isConnected
                  ? 'Connected'
                  : 'Connecting...'}
            </span>
          </div>
        </div>
      </div>
    </div>
  );
};

================================================
FILE: src/features/call/components/call-button.tsx
================================================

// ================================================
// FILE: src/features/call/components/call-button.tsx
// CallButton Component - Initiate call button
// ================================================

import { Phone, Video } from 'lucide-react';
import { Button } from '@/shared/components/ui/button';
import { CallType } from '../types/call.types';

interface CallButtonProps {
  type: 'voice' | 'video';
  onClick: () => void;
  disabled?: boolean;
  size?: 'sm' | 'default' | 'lg' | 'icon';
}

export const CallButton = ({
  type,
  onClick,
  disabled,
  size = 'icon'
}: CallButtonProps) => {
  const Icon = type === 'voice' ? Phone : Video;

  return (
    <Button
      variant="ghost"
      size={size}
      onClick={onClick}
      disabled={disabled}
      className="text-muted-foreground hover:text-primary"
    >
      <Icon className="h-5 w-5" />
    </Button>
  );
};

================================================
FILE: src/features/call/components/call-controls.tsx
================================================

// ================================================
// FILE: src/features/call/components/call-controls.tsx
// CallControls Component - In-call controls
// ================================================

import { Mic, MicOff, Video, VideoOff, PhoneOff } from 'lucide-react';
import { Button } from '@/shared/components/ui/button';
import { cn } from '@/shared/utils/cn';

interface CallControlsProps {
  isMuted: boolean;
  isVideoEnabled: boolean;
  onToggleMute: () => void;
  onToggleVideo: () => void;
  onEndCall: () => void;
  isVideoCall?: boolean;
}

export const CallControls = ({
  isMuted,
  isVideoEnabled,
  onToggleMute,
  onToggleVideo,
  onEndCall,
  isVideoCall = false,
}: CallControlsProps) => {
  return (
    <div className="flex items-center justify-center gap-4 rounded-lg bg-background/80 p-4 backdrop-blur">
      {/* Mute/Unmute */}
      <Button
        size="lg"
        variant={isMuted ? 'destructive' : 'secondary'}
        onClick={onToggleMute}
        className="h-14 w-14 rounded-full"
      >
        {isMuted ? (
          <MicOff className="h-6 w-6" />
        ) : (
          <Mic className="h-6 w-6" />
        )}
      </Button>

      {/* Video Toggle (only for video calls) */}
      {isVideoCall && (
        <Button
          size="lg"
          variant={!isVideoEnabled ? 'destructive' : 'secondary'}
          onClick={onToggleVideo}
          className="h-14 w-14 rounded-full"
        >
          {isVideoEnabled ? (
            <Video className="h-6 w-6" />
          ) : (
            <VideoOff className="h-6 w-6" />
          )}
        </Button>
      )}

      {/* End Call */}
      <Button
        size="lg"
        variant="destructive"
        onClick={onEndCall}
        className="h-14 w-14 rounded-full"
      >
        <PhoneOff className="h-6 w-6" />
      </Button>
    </div>
  );
};

================================================
FILE: src/features/call/components/call-history-item.tsx
================================================

// ================================================
// FILE: src/features/call/components/call-history-item.tsx
// CallHistoryItem Component - Single call history item
// ================================================

import {
  Phone,
  Video,
  PhoneIncoming,
  PhoneOutgoing,
  PhoneMissed
} from 'lucide-react';
import { UserAvatar } from '@/shared/components/common/user-avatar';
import { dateFormatter } from '@/shared/utils/date-formatter';
import { cn } from '@/shared/utils/cn';
import type { CallWithDetails } from '../types/call.types';

interface CallHistoryItemProps {
  call: CallWithDetails;
  currentUserId: string;
  onClick?: () => void;
}

export const CallHistoryItem = ({
  call,
  currentUserId,
  onClick,
}: CallHistoryItemProps) => {
  const isIncoming = call.receiverId === currentUserId;
  const isMissed = call.status === 'MISSED';
  const isRejected = call.status === 'REJECTED';
  const isVideo = call.type === 'VIDEO';

  const otherUser = isIncoming ? call.caller : call.receiver;

  const getIcon = () => {
    if (isMissed || isRejected) {
      return <PhoneMissed className="h-5 w-5 text-destructive" />;
    }
    if (isIncoming) {
      return <PhoneIncoming className="h-5 w-5 text-green-500" />;
    }
    return <PhoneOutgoing className="h-5 w-5 text-blue-500" />;
  };

  const getStatusText = () => {
    if (isMissed) return 'Missed';
    if (isRejected) return 'Rejected';
    if (call.duration) {
      return dateFormatter.callDuration(call.duration);
    }
    return call.status;
  };

  return (
    <div
      onClick={onClick}
      className="flex cursor-pointer items-center gap-3 p-4 transition-colors hover:bg-muted/50"
    >
      <UserAvatar
        src={otherUser.avatar}
        name={otherUser.name}
        size="lg"
      />

      <div className="flex-1">
        <div className="flex items-center gap-2">
          {getIcon()}
          <h4 className="font-semibold text-foreground">
            {otherUser.name}
          </h4>
        </div>

        <div className="flex items-center gap-2 text-sm text-muted-foreground">
          {isVideo && <Video className="h-4 w-4" />}
          <span>{getStatusText()}</span>
          <span>‚Ä¢</span>
          <span>{dateFormatter.relativeTime(call.createdAt)}</span>
        </div>
      </div>

      <Phone className="h-5 w-5 text-muted-foreground" />
    </div>
  );
};

================================================
FILE: src/features/call/components/incoming-call-modal.tsx
================================================

// ================================================
// FILE: src/features/call/components/incoming-call-modal.tsx
// FIXED: Added button disabling to prevent spam clicks
// ================================================

import { useEffect, useRef, useState } from 'react';
import { Phone, PhoneOff, Video, Loader2 } from 'lucide-react';
import {
  Dialog,
  DialogContent,
} from '@/shared/components/ui/dialog';
import { Button } from '@/shared/components/ui/button';
import { UserAvatar } from '@/shared/components/common/user-avatar';
import type { CallWithDetails } from '../types/call.types';

interface IncomingCallModalProps {
  call: CallWithDetails | null;
  onAnswer: () => void;
  onReject: () => void;
}

export const IncomingCallModal = ({
  call,
  onAnswer,
  onReject,
}: IncomingCallModalProps) => {
  const audioRef = useRef<HTMLAudioElement | null>(null);

  // ‚úÖ ADD: Local state to prevent button spam
  const [isAnswering, setIsAnswering] = useState(false);
  const [isRejecting, setIsRejecting] = useState(false);

  // Play ringtone when call comes in
  useEffect(() => {
    if (call) {
      // Reset states when new call comes in
      setIsAnswering(false);
      setIsRejecting(false);

      // Create and play ringtone
      try {
        audioRef.current = new Audio('/sounds/ringtone.mp3');
        audioRef.current.loop = true;
        audioRef.current.volume = 0.5;
        audioRef.current.play().catch(() => { });
      } catch (e) {
        // Ignore audio errors
      }
    }

    return () => {
      // Stop ringtone when modal closes
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
        audioRef.current = null;
      }
    };
  }, [call]);

  const handleAnswer = async () => {
    // ‚úÖ PREVENT: Multiple clicks
    if (isAnswering || isRejecting) {
      return;
    }

    setIsAnswering(true);

    // Stop ringtone
    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current = null;
    }

    try {
      await onAnswer();
    } catch (error) {
      // Reset on error so user can try again
      setIsAnswering(false);
    }
  };

  const handleReject = async () => {
    // ‚úÖ PREVENT: Multiple clicks
    if (isAnswering || isRejecting) {
      return;
    }

    setIsRejecting(true);

    // Stop ringtone
    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current = null;
    }

    try {
      await onReject();
    } catch (error) {
      // Reset on error so user can try again
      setIsRejecting(false);
    }
  };

  if (!call) return null;

  const isVideo = call.type === 'VIDEO';
  const isProcessing = isAnswering || isRejecting;

  return (
    <Dialog open={!!call} onOpenChange={() => { }}>
      <DialogContent
        className="sm:max-w-md bg-gradient-to-b from-gray-900 to-gray-800 border-gray-700"
        onPointerDownOutside={(e) => e.preventDefault()}
        onEscapeKeyDown={(e) => e.preventDefault()}
      >
        <div className="flex flex-col items-center gap-6 py-6">
          {/* Animated ring around avatar */}
          <div className="relative">
            {!isProcessing && (
              <>
                <div className="absolute inset-0 rounded-full animate-ping bg-green-500/30" />
                <div className="absolute inset-0 rounded-full animate-pulse bg-green-500/20" />
              </>
            )}
            <UserAvatar
              src={call.caller.avatar}
              name={call.caller.name}
              size="xl"
              className="relative z-10 w-28 h-28"
            />
          </div>

          {/* Call info */}
          <div className="text-center">
            <h3 className="text-2xl font-semibold text-white">
              {call.caller.name}
            </h3>
            <p className="text-gray-400 mt-1">
              {isAnswering
                ? 'üìû Connecting...'
                : isRejecting
                  ? '‚ùå Declining...'
                  : isVideo
                    ? 'üìπ Incoming Video Call...'
                    : 'üìû Incoming Voice Call...'}
            </p>
          </div>

          {/* Action Buttons */}
          <div className="flex gap-8 mt-4">
            {/* Reject */}
            <div className="flex flex-col items-center gap-2">
              <Button
                size="lg"
                variant="destructive"
                onClick={handleReject}
                disabled={isProcessing}
                className="h-16 w-16 rounded-full bg-red-600 hover:bg-red-700 disabled:opacity-50"
                style={!isProcessing ? { animationDuration: '2s' } : {}}
              >
                {isRejecting ? (
                  <Loader2 className="h-7 w-7 animate-spin" />
                ) : (
                  <PhoneOff className="h-7 w-7" />
                )}
              </Button>
              <span className="text-sm text-gray-400">Decline</span>
            </div>

            {/* Answer */}
            <div className="flex flex-col items-center gap-2">
              <Button
                size="lg"
                onClick={handleAnswer}
                disabled={isProcessing}
                className="h-16 w-16 rounded-full bg-green-600 hover:bg-green-700 disabled:opacity-50"
                style={!isProcessing ? { animationDuration: '2s', animationDelay: '0.5s' } : {}}
              >
                {isAnswering ? (
                  <Loader2 className="h-7 w-7 animate-spin" />
                ) : isVideo ? (
                  <Video className="h-7 w-7" />
                ) : (
                  <Phone className="h-7 w-7" />
                )}
              </Button>
              <span className="text-sm text-gray-400">Accept</span>
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};

================================================
FILE: src/features/call/hooks/use-call.ts
================================================

// ================================================
// FILE: src/features/call/hooks/use-call.ts
// CLEANED: Removed useCallSocket (moved to SocketProvider)
// ================================================

import { useEffect, useRef, useCallback } from 'react';
import { useCallStore } from '../store/call.store';
import { logger } from '@/shared/utils/logger';
import type { InitiateCallInput } from '../types/call.types';

let GLOBAL_CALL_HISTORY_FETCHED = false;

export const useCall = () => {
  const {
    activeCall,
    incomingCall,
    callHistory,
    isLoading,
    error,
    isMuted,
    isVideoEnabled,
    isConnected,
    connectionState,
    localStream,
    remoteStream,
    initiateCall,
    answerCall,
    rejectCall,
    endCall,
    fetchCallHistory,
    deleteCallLog,
    toggleMute,
    toggleVideo,
    cleanupStreams,
    clearError,
  } = useCallStore();

  // ‚úÖ REMOVED: useCallSocket() - now handled in SocketProvider

  const isAnsweringRef = useRef(false);
  const isRejectingRef = useRef(false);
  const isEndingRef = useRef(false);
  const isInitiatingRef = useRef(false);

  useEffect(() => {
    if (!GLOBAL_CALL_HISTORY_FETCHED) {
      logger.debug('useCall: Fetching call history (first time only)');
      fetchCallHistory();
      GLOBAL_CALL_HISTORY_FETCHED = true;
    }
  }, [fetchCallHistory]);

  const handleInitiateCall = useCallback(async (data: InitiateCallInput) => {
    if (isInitiatingRef.current) {
      logger.warn('useCall: Initiate already in progress, ignoring...');
      return null;
    }

    if (activeCall) {
      logger.warn('useCall: Already in a call, ignoring...');
      return null;
    }

    isInitiatingRef.current = true;

    try {
      logger.debug('useCall: Initiating call...');
      const call = await initiateCall(data);
      logger.success('useCall: Call created');
      return call;
    } catch (error) {
      logger.error('useCall: Failed to initiate call:', error);
      throw error;
    } finally {
      setTimeout(() => {
        isInitiatingRef.current = false;
      }, 1000);
    }
  }, [activeCall, initiateCall]);

  const handleAnswerCall = useCallback(async (callId: string) => {
    if (isAnsweringRef.current) {
      logger.warn('useCall: Answer already in progress, ignoring...');
      return;
    }

    isAnsweringRef.current = true;

    try {
      logger.debug('useCall: Answering call:', callId);
      await answerCall(callId);
      logger.success('useCall: Call answered');
    } catch (error) {
      logger.error('useCall: Failed to answer call:', error);
      throw error;
    } finally {
      setTimeout(() => {
        isAnsweringRef.current = false;
      }, 2000);
    }
  }, [answerCall]);

  const handleRejectCall = useCallback(async (callId: string) => {
    if (isRejectingRef.current) {
      logger.warn('useCall: Reject already in progress, ignoring...');
      return;
    }

    isRejectingRef.current = true;

    try {
      logger.debug('useCall: Rejecting call:', callId);
      await rejectCall(callId);
      logger.success('useCall: Call rejected');
    } catch (error) {
      logger.error('useCall: Failed to reject call:', error);
      throw error;
    } finally {
      setTimeout(() => {
        isRejectingRef.current = false;
      }, 1000);
    }
  }, [rejectCall]);

  const handleEndCall = useCallback(async (callId: string, duration?: number) => {
    if (isEndingRef.current) {
      logger.warn('useCall: End already in progress, ignoring...');
      return;
    }

    isEndingRef.current = true;

    try {
      logger.debug('useCall: Ending call:', callId);
      await endCall(callId, duration);
      logger.success('useCall: Call ended');
    } catch (error) {
      logger.error('useCall: Failed to end call:', error);
      throw error;
    } finally {
      setTimeout(() => {
        isEndingRef.current = false;
      }, 1000);
    }
  }, [endCall]);

  const handleDeleteCallLog = useCallback(async (callId: string) => {
    try {
      logger.debug('useCall: Deleting call log:', callId);
      await deleteCallLog(callId);
      logger.success('useCall: Call log deleted');
    } catch (error) {
      logger.error('useCall: Failed to delete call log:', error);
      throw error;
    }
  }, [deleteCallLog]);

  return {
    activeCall,
    incomingCall,
    callHistory,
    isLoading,
    error,
    isMuted,
    isVideoEnabled,
    isConnected,
    connectionState,
    localStream,
    remoteStream,
    initiateCall: handleInitiateCall,
    answerCall: handleAnswerCall,
    rejectCall: handleRejectCall,
    endCall: handleEndCall,
    deleteCallLog: handleDeleteCallLog,
    toggleMute,
    toggleVideo,
    cleanupStreams,
    clearError,
  };
};

export const resetCallFetch = () => {
  GLOBAL_CALL_HISTORY_FETCHED = false;
  logger.debug('useCall: Reset fetch flag');
};

================================================
FILE: src/features/call/hooks/use-webrtc.ts
================================================

// ================================================
// FILE: src/features/call/hooks/use-webrtc.ts
// FIXED: Fresh Xirsys Credentials + Hybrid STUN/TURN
// ================================================

import { useEffect, useRef, useCallback, useState } from 'react';
import { socketClient } from '@/lib/socket-client';
import { useCallStore } from '../store/call.store';
import { SOCKET_EVENTS } from '@/shared/constants/socket-events';
import { toastHelper } from '@/shared/utils/toast-helper';

// ‚úÖ FRESH XIRSYS CREDENTIALS (Updated: December 10, 2025)
const ICE_SERVERS: RTCConfiguration = {
  iceServers: [
    // 1. Xirsys STUN
    {
      urls: ['stun:ss-turn2.xirsys.com']
    },
    // 2. Public STUN (Google)
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
    // 3. Xirsys TURN (Fallback)
    {
      username: 'sW0wJKS6XcZfp3ObOHqUV8_8aFsIzAewbVVcfXKV_YJ9BKBmwqd-37RxLRVNdz33AAAAAGk40wZmaWJpZHk=',
      credential: '477a8f94-d56b-11f0-ac7a-0242ac140004',
      urls: [
        'turn:ss-turn2.xirsys.com:80?transport=udp',
        'turn:ss-turn2.xirsys.com:3478?transport=udp',
        'turn:ss-turn2.xirsys.com:80?transport=tcp',
        'turn:ss-turn2.xirsys.com:3478?transport=tcp',
        'turns:ss-turn2.xirsys.com:443?transport=tcp',
        'turns:ss-turn2.xirsys.com:5349?transport=tcp',
      ]
    }
  ],
  iceCandidatePoolSize: 10,
};

interface UseWebRTCProps {
  callId: string;
  otherUserId: string;
  isCaller: boolean;
  isVideoCall: boolean;
}

interface WebRTCSignalData {
  callId: string;
  signal: RTCSessionDescriptionInit | RTCIceCandidateInit;
  to: string;
  from?: string;
}

export const useWebRTC = ({ callId, otherUserId, isCaller, isVideoCall }: UseWebRTCProps) => {
  const {
    setLocalStream,
    setRemoteStream,
    setIsConnected,
    setConnectionState,
    activeCall,
  } = useCallStore();

  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);
  const localStreamRef = useRef<MediaStream | null>(null);
  const pendingCandidatesRef = useRef<RTCIceCandidate[]>([]);
  const isCleanedUpRef = useRef(false);
  const hasCreatedOfferRef = useRef(false);
  const hasAddedTracksRef = useRef(false);

  const [isInitialized, setIsInitialized] = useState(false);
  const [mediaError, setMediaError] = useState<string | null>(null);

  const isCallAnswered = activeCall?.status === 'ANSWERED';

  const getUserMedia = useCallback(async () => {
    if (isCleanedUpRef.current) {
      throw new Error('WebRTC already cleaned up');
    }

    try {
      console.log('üé§ WebRTC: Requesting user media...');

      const constraints: MediaStreamConstraints = {
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
        },
        video: isVideoCall ? {
          width: { ideal: 1280 },
          height: { ideal: 720 },
          facingMode: 'user',
        } : false,
      };

      const stream = await navigator.mediaDevices.getUserMedia(constraints);

      if (isCleanedUpRef.current) {
        stream.getTracks().forEach(track => track.stop());
        throw new Error('WebRTC cleaned up during media acquisition');
      }

      localStreamRef.current = stream;
      setLocalStream(stream);
      setMediaError(null);

      console.log('‚úÖ WebRTC: User media obtained -', stream.getTracks().map(t => t.kind).join(', '));
      return stream;
    } catch (error: any) {
      console.error('‚ùå WebRTC: Failed to get user media:', error);
      setMediaError('Failed to access camera/microphone');
      toastHelper.error('Failed to access camera/microphone');
      throw error;
    }
  }, [isVideoCall, setLocalStream]);

  const createPeerConnection = useCallback(() => {
    if (peerConnectionRef.current) {
      console.log('‚ôªÔ∏è WebRTC: Reusing existing peer connection');
      return peerConnectionRef.current;
    }

    if (isCleanedUpRef.current) {
      console.warn('‚ö†Ô∏è WebRTC: Cannot create peer connection - already cleaned up');
      return null;
    }

    console.log('üîß WebRTC: Creating NEW peer connection...');
    console.log('üîß WebRTC: ICE Servers:', JSON.stringify(ICE_SERVERS.iceServers?.map(s => {
      if (typeof s === 'string') return s;
      if ('username' in s) return { urls: s.urls, hasAuth: true };
      return s.urls;
    }), null, 2));

    const pc = new RTCPeerConnection(ICE_SERVERS);
    peerConnectionRef.current = pc;

    pc.onicegatheringstatechange = () => {
      console.log('üîÑ WebRTC: ICE gathering state:', pc.iceGatheringState);
    };

    pc.onicecandidate = (event) => {
      if (isCleanedUpRef.current) return;

      if (event.candidate) {
        console.log('üßä WebRTC: ICE Candidate:', {
          type: event.candidate.type,
          protocol: event.candidate.protocol,
          address: event.candidate.address || 'hidden',
          port: event.candidate.port,
        });

        socketClient.emit(SOCKET_EVENTS.WEBRTC_ICE, {
          callId,
          signal: event.candidate.toJSON(),
          to: otherUserId,
        });
      } else {
        console.log('üßä WebRTC: ICE gathering complete');
      }
    };

    pc.oniceconnectionstatechange = () => {
      const state = pc.iceConnectionState;
      console.log('üîå WebRTC: ICE connection state:', state);

      if (isCleanedUpRef.current) return;

      if (state === 'connected' || state === 'completed') {
        setIsConnected(true);
        console.log('‚úÖ WebRTC: ICE Connected!');
        toastHelper.success('Call connected!');
      } else if (state === 'disconnected') {
        setIsConnected(false);
        console.warn('‚ö†Ô∏è WebRTC: ICE Disconnected - attempting reconnect...');
        // Don't close connection yet, might reconnect
      } else if (state === 'failed') {
        setIsConnected(false);
        console.error('‚ùå WebRTC: ICE Connection failed');
        toastHelper.error('Connection failed - please try again');
      } else if (state === 'checking') {
        console.log('üîç WebRTC: ICE Checking connectivity...');
      }
    };

    pc.onconnectionstatechange = () => {
      const state = pc.connectionState;
      console.log('üì° WebRTC: Connection state:', state);

      if (isCleanedUpRef.current) return;

      setConnectionState(state);

      if (state === 'connected') {
        setIsConnected(true);
      } else if (state === 'failed') {
        setIsConnected(false);
        toastHelper.error('Connection failed');
      }
    };

    pc.ontrack = (event) => {
      if (isCleanedUpRef.current) return;

      console.log('üé• WebRTC: Remote track received:', event.track.kind);
      if (event.streams && event.streams[0]) {
        console.log('‚úÖ WebRTC: Setting remote stream');
        setRemoteStream(event.streams[0]);
      }
    };

    console.log('‚úÖ WebRTC: Peer connection created');
    return pc;
  }, [callId, otherUserId, setIsConnected, setConnectionState, setRemoteStream]);

  const addTracksToConnection = useCallback((pc: RTCPeerConnection, stream: MediaStream) => {
    if (hasAddedTracksRef.current) {
      console.log('‚ö†Ô∏è WebRTC: Tracks already added, skipping...');
      return;
    }

    stream.getTracks().forEach((track) => {
      pc.addTrack(track, stream);
      console.log('‚ûï WebRTC: Added track:', track.kind);
    });

    hasAddedTracksRef.current = true;
    console.log('‚úÖ WebRTC: All tracks added to peer connection');
  }, []);

  const createAndSendOffer = useCallback(async () => {
    if (isCleanedUpRef.current) {
      console.warn('‚ö†Ô∏è WebRTC: Cannot send offer - cleaned up');
      return;
    }

    if (hasCreatedOfferRef.current) {
      console.warn('‚ö†Ô∏è WebRTC: Offer already created, skipping...');
      return;
    }

    const pc = peerConnectionRef.current;
    if (!pc) {
      console.error('‚ùå WebRTC: No peer connection for offer');
      return;
    }

    try {
      hasCreatedOfferRef.current = true;
      console.log('üì§ WebRTC: Creating offer...');

      const offer = await pc.createOffer({
        offerToReceiveAudio: true,
        offerToReceiveVideo: isVideoCall,
        iceRestart: false, // ‚úÖ Set to true if want to force ICE restart
      });

      if (isCleanedUpRef.current) {
        console.warn('‚ö†Ô∏è WebRTC: Cleaned up during offer creation');
        return;
      }

      await pc.setLocalDescription(offer);

      console.log('üì§ WebRTC: Sending offer to:', otherUserId);

      socketClient.emit(SOCKET_EVENTS.WEBRTC_OFFER, {
        callId,
        signal: offer,
        to: otherUserId,
      });

      console.log('‚úÖ WebRTC: Offer sent!');
    } catch (error) {
      hasCreatedOfferRef.current = false;
      console.error('‚ùå WebRTC: Failed to create offer:', error);
      toastHelper.error('Failed to establish connection');
    }
  }, [callId, otherUserId, isVideoCall]);

  const handleOffer = useCallback(async (data: WebRTCSignalData) => {
    if (data.callId !== callId) return;
    if (!('type' in data.signal) || data.signal.type !== 'offer') return;
    if (isCleanedUpRef.current) return;

    console.log('üì• WebRTC: Received offer from caller');

    let pc = peerConnectionRef.current;

    if (!pc) {
      console.log('üîß WebRTC: Creating peer connection for incoming offer...');

      if (!localStreamRef.current) {
        try {
          await getUserMedia();
        } catch (error) {
          console.error('‚ùå WebRTC: Failed to get media for answer:', error);
          return;
        }
      }

      pc = createPeerConnection();
      if (!pc) {
        console.error('‚ùå WebRTC: Failed to create peer connection');
        return;
      }
    }

    if (localStreamRef.current && !hasAddedTracksRef.current) {
      addTracksToConnection(pc, localStreamRef.current);
    }

    try {
      console.log('üì• WebRTC: Setting remote description (offer)...');
      await pc.setRemoteDescription(new RTCSessionDescription(data.signal as RTCSessionDescriptionInit));

      for (const candidate of pendingCandidatesRef.current) {
        await pc.addIceCandidate(candidate);
        console.log('‚úÖ WebRTC: Added pending ICE candidate');
      }
      pendingCandidatesRef.current = [];

      if (isCleanedUpRef.current) return;

      console.log('üì§ WebRTC: Creating answer...');
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      console.log('üì§ WebRTC: Sending answer to:', otherUserId);

      socketClient.emit(SOCKET_EVENTS.WEBRTC_ANSWER, {
        callId,
        signal: answer,
        to: otherUserId,
      });

      console.log('‚úÖ WebRTC: Answer sent!');
    } catch (error) {
      console.error('‚ùå WebRTC: Failed to handle offer:', error);
    }
  }, [callId, otherUserId, getUserMedia, createPeerConnection, addTracksToConnection]);

  const handleAnswer = useCallback(async (data: WebRTCSignalData) => {
    if (data.callId !== callId) return;
    if (!('type' in data.signal) || data.signal.type !== 'answer') return;
    if (isCleanedUpRef.current) return;

    const pc = peerConnectionRef.current;
    if (!pc) {
      console.error('‚ùå WebRTC: No peer connection for handling answer');
      return;
    }

    try {
      console.log('üì• WebRTC: Received answer from receiver');

      await pc.setRemoteDescription(new RTCSessionDescription(data.signal as RTCSessionDescriptionInit));

      for (const candidate of pendingCandidatesRef.current) {
        await pc.addIceCandidate(candidate);
        console.log('‚úÖ WebRTC: Added pending ICE candidate');
      }
      pendingCandidatesRef.current = [];

      console.log('‚úÖ WebRTC: Answer applied, connection should establish...');
    } catch (error) {
      console.error('‚ùå WebRTC: Failed to handle answer:', error);
    }
  }, [callId]);

  const handleICE = useCallback(async (data: WebRTCSignalData) => {
    if (data.callId !== callId) return;
    if (!('candidate' in data.signal)) return;
    if (isCleanedUpRef.current) return;

    const pc = peerConnectionRef.current;

    try {
      const candidate = new RTCIceCandidate(data.signal as RTCIceCandidateInit);

      if (pc && pc.remoteDescription) {
        await pc.addIceCandidate(candidate);
        console.log('‚úÖ WebRTC: ICE candidate added');
      } else {
        pendingCandidatesRef.current.push(candidate);
        console.log('üì¶ WebRTC: ICE candidate queued (waiting for remote description)');
      }
    } catch (error) {
      console.error('‚ùå WebRTC: Failed to add ICE candidate:', error);
    }
  }, [callId]);

  const initializeCall = useCallback(async () => {
    if (isInitialized) {
      console.warn('‚ö†Ô∏è WebRTC: Already initialized');
      return;
    }

    if (isCleanedUpRef.current) {
      console.warn('‚ö†Ô∏è WebRTC: Cannot initialize - already cleaned up');
      return;
    }

    try {
      console.log('üöÄ WebRTC: Initializing...', { isCaller, isVideoCall, callId });

      const stream = await getUserMedia();

      const pc = createPeerConnection();
      if (!pc) {
        throw new Error('Failed to create peer connection');
      }

      addTracksToConnection(pc, stream);

      setIsInitialized(true);

      if (isCaller) {
        console.log('üìû WebRTC: Caller ready, waiting for receiver to answer...');
      } else {
        console.log('üìû WebRTC: Receiver ready, waiting for offer...');
      }

      console.log('‚úÖ WebRTC: Initialization complete');
    } catch (error) {
      console.error('‚ùå WebRTC: Failed to initialize:', error);
    }
  }, [isInitialized, isCaller, isVideoCall, callId, getUserMedia, createPeerConnection, addTracksToConnection]);

  useEffect(() => {
    if (isCaller && isInitialized && isCallAnswered && !hasCreatedOfferRef.current && !isCleanedUpRef.current) {
      console.log('üéØ WebRTC: Call ANSWERED! Caller sending offer in 1 second...');

      const timeout = setTimeout(() => {
        if (!isCleanedUpRef.current && !hasCreatedOfferRef.current) {
          createAndSendOffer();
        }
      }, 1000);

      return () => clearTimeout(timeout);
    }
  }, [isCaller, isInitialized, isCallAnswered, createAndSendOffer]);

  // ‚úÖ CONNECTION TIMEOUT - Auto fail after 30s if not connected
  useEffect(() => {
    if (!isInitialized || isCleanedUpRef.current) return;

    const timeoutId = setTimeout(() => {
      const pc = peerConnectionRef.current;
      if (pc && pc.iceConnectionState !== 'connected' && pc.iceConnectionState !== 'completed') {
        console.error('‚ùå WebRTC: Connection timeout (30s) - ICE state:', pc.iceConnectionState);
        toastHelper.error('Connection timeout. Please try again.');
      }
    }, 30000); // 30 seconds

    return () => clearTimeout(timeoutId);
  }, [isInitialized]);

  const cleanup = useCallback(() => {
    console.log('üßπ WebRTC: Cleaning up...');

    isCleanedUpRef.current = true;
    hasCreatedOfferRef.current = false;
    hasAddedTracksRef.current = false;

    if (peerConnectionRef.current) {
      peerConnectionRef.current.close();
      peerConnectionRef.current = null;
    }

    if (localStreamRef.current) {
      localStreamRef.current.getTracks().forEach(track => track.stop());
      localStreamRef.current = null;
    }

    pendingCandidatesRef.current = [];
    setIsInitialized(false);

    console.log('‚úÖ WebRTC: Cleanup complete');
  }, []);

  useEffect(() => {
    isCleanedUpRef.current = false;
    hasCreatedOfferRef.current = false;
    hasAddedTracksRef.current = false;
  }, [callId]);

  useEffect(() => {
    console.log('üëÇ WebRTC: Setting up socket listeners for callId:', callId);

    socketClient.on(SOCKET_EVENTS.WEBRTC_OFFER, handleOffer);
    socketClient.on(SOCKET_EVENTS.WEBRTC_ANSWER, handleAnswer);
    socketClient.on(SOCKET_EVENTS.WEBRTC_ICE, handleICE);

    return () => {
      socketClient.off(SOCKET_EVENTS.WEBRTC_OFFER, handleOffer);
      socketClient.off(SOCKET_EVENTS.WEBRTC_ANSWER, handleAnswer);
      socketClient.off(SOCKET_EVENTS.WEBRTC_ICE, handleICE);
    };
  }, [callId, handleOffer, handleAnswer, handleICE]);

  useEffect(() => {
    return () => {
      cleanup();
    };
  }, [cleanup]);

  return {
    initializeCall,
    cleanup,
    isInitialized,
    mediaError,
  };
};

================================================
FILE: src/features/call/pages/calls-page.tsx
================================================

// ================================================
// FILE: src/features/call/pages/calls-page.tsx
// CallsPage - WITHOUT INCOMING CALL MODAL (moved to AppLayout)
// ================================================

import { Phone } from 'lucide-react';
import { AppLayout } from '@/shared/components/layouts/app-layout';
import { PageLayout } from '@/shared/components/common/page-layout';
import { EmptyState } from '@/shared/components/common/empty-state';
import { LoadingSpinner } from '@/shared/components/common/loading-spinner';
import { CallHistoryItem } from '../components/call-history-item';
import { useCall } from '../hooks/use-call';
import { useAuthStore } from '@/features/auth/store/auth.store';

export const CallsPage = () => {
  const { user } = useAuthStore();
  const { callHistory, isLoading } = useCall();

  const header = (
    <div>
      <h1 className="text-2xl font-bold">Calls</h1>
      <p className="text-muted-foreground">Your call history</p>
    </div>
  );

  return (
    <AppLayout>
      <PageLayout header={header}>
        {isLoading ? (
          <div className="flex h-64 items-center justify-center">
            <LoadingSpinner text="Loading calls..." />
          </div>
        ) : callHistory.length === 0 ? (
          <EmptyState
            icon={Phone}
            title="No calls yet"
            description="Your call history will appear here"
          />
        ) : (
          <div className="divide-y">
            {callHistory.map((call) => (
              <CallHistoryItem
                key={call.id}
                call={call}
                currentUserId={user?.id || ''}
              />
            ))}
          </div>
        )}
      </PageLayout>
    </AppLayout>
  );
};

================================================
FILE: src/features/call/services/call.service.ts
================================================

// ================================================
// FILE: src/features/call/services/call.service.ts
// Call Service - Handle all call API calls (CLEANED)
// ================================================

import { axiosClient } from '@/lib/axios-client';
import { API_ENDPOINTS } from '@/shared/constants/api-endpoints';
import { logger } from '@/shared/utils/logger';
import type { ApiResponse } from '@/shared/types/api-types';
import type {
  InitiateCallInput,
  CallWithDetails
} from '../types/call.types';

export const callService = {
  // Initiate call
  initiateCall: async (data: InitiateCallInput): Promise<CallWithDetails> => {
    logger.debug('Call Service: Initiating call...');

    const response = await axiosClient.post<ApiResponse<CallWithDetails>>(
      API_ENDPOINTS.CALL.INITIATE,
      data
    );

    logger.success('Call Service: Call initiated');

    return response.data.data!;
  },

  // Answer call
  answerCall: async (callId: string): Promise<CallWithDetails> => {
    logger.debug('Call Service: Answering call:', callId);

    const response = await axiosClient.post<ApiResponse<CallWithDetails>>(
      API_ENDPOINTS.CALL.ANSWER(callId)
    );

    logger.success('Call Service: Call answered');

    return response.data.data!;
  },

  // End call
  endCall: async (callId: string, duration?: number): Promise<CallWithDetails> => {
    logger.debug('Call Service: Ending call:', callId);

    const response = await axiosClient.post<ApiResponse<CallWithDetails>>(
      API_ENDPOINTS.CALL.END(callId),
      { duration }
    );

    logger.success('Call Service: Call ended');

    return response.data.data!;
  },

  // Reject call
  rejectCall: async (callId: string): Promise<CallWithDetails> => {
    logger.debug('Call Service: Rejecting call:', callId);

    const response = await axiosClient.post<ApiResponse<CallWithDetails>>(
      API_ENDPOINTS.CALL.REJECT(callId)
    );

    logger.success('Call Service: Call rejected');

    return response.data.data!;
  },

  // Get call history
  getCallHistory: async (): Promise<CallWithDetails[]> => {
    logger.debug('Call Service: Getting call history...');

    const response = await axiosClient.get<ApiResponse<CallWithDetails[]>>(
      API_ENDPOINTS.CALL.HISTORY
    );

    logger.success('Call Service: Call history retrieved:', response.data.data?.length || 0);

    return response.data.data || [];
  },

  // Delete call log
  deleteCallLog: async (callId: string): Promise<void> => {
    logger.debug('Call Service: Deleting call log:', callId);

    await axiosClient.delete(API_ENDPOINTS.CALL.DELETE(callId));

    logger.success('Call Service: Call log deleted');
  },
};

================================================
FILE: src/features/call/store/call.store.ts
================================================

// ================================================
// FILE: src/features/call/store/call.store.ts
// FIXED V2: Proper state management with operation locks
// ================================================

import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { callService } from '../services/call.service';
import { toastHelper } from '@/shared/utils/toast-helper';
import { logger } from '@/shared/utils/logger';
import type {
  CallWithDetails,
  InitiateCallInput,
} from '../types/call.types';

interface CallState {
  // State
  activeCall: CallWithDetails | null;
  incomingCall: CallWithDetails | null;
  callHistory: CallWithDetails[];
  isLoading: boolean;
  error: string | null;

  // WebRTC state
  localStream: MediaStream | null;
  remoteStream: MediaStream | null;
  isMuted: boolean;
  isVideoEnabled: boolean;
  isConnected: boolean;
  connectionState: string;

  // Operation locks
  isAnswering: boolean;
  isRejecting: boolean;
  isEnding: boolean;
  isInitiating: boolean;

  // Actions - Call
  initiateCall: (data: InitiateCallInput) => Promise<CallWithDetails>;
  answerCall: (callId: string) => Promise<void>;
  rejectCall: (callId: string) => Promise<void>;
  endCall: (callId: string, duration?: number) => Promise<void>;
  setIncomingCall: (call: CallWithDetails | null) => void;
  setActiveCall: (call: CallWithDetails | null) => void;

  // Actions - Call History
  fetchCallHistory: () => Promise<void>;
  deleteCallLog: (callId: string) => Promise<void>;

  // Actions - WebRTC
  setLocalStream: (stream: MediaStream | null) => void;
  setRemoteStream: (stream: MediaStream | null) => void;
  setIsConnected: (connected: boolean) => void;
  setConnectionState: (state: string) => void;
  toggleMute: () => void;
  toggleVideo: () => void;

  // Utils
  clearError: () => void;
  reset: () => void;
  cleanupStreams: () => void;
}

export const useCallStore = create<CallState>()(
  devtools(
    (set, get) => ({
      // Initial state
      activeCall: null,
      incomingCall: null,
      callHistory: [],
      isLoading: false,
      error: null,
      localStream: null,
      remoteStream: null,
      isMuted: false,
      isVideoEnabled: true,
      isConnected: false,
      connectionState: 'new',
      isAnswering: false,
      isRejecting: false,
      isEnding: false,
      isInitiating: false,

      // Initiate call
      initiateCall: async (data) => {
        const state = get();

        if (state.isInitiating) {
          logger.warn('Call Store: Initiate already in progress');
          throw new Error('Call initiation already in progress');
        }

        if (state.activeCall) {
          logger.warn('Call Store: Already in a call');
          throw new Error('Already in a call');
        }

        set({ isInitiating: true, isLoading: true, error: null });

        try {
          logger.debug('Call Store: Initiating call...');
          const call = await callService.initiateCall(data);

          toastHelper.success('Calling...');

          set({
            activeCall: call,
            isLoading: false,
            isInitiating: false,
          });

          logger.success('Call Store: Call initiated:', call.id);
          return call;
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to initiate call';

          logger.error('Call Store: Initiate call failed:', error);
          toastHelper.error(errorMsg);

          set({
            error: errorMsg,
            isLoading: false,
            isInitiating: false,
          });
          throw error;
        }
      },

      // Answer call
      answerCall: async (callId) => {
        const state = get();

        if (state.isAnswering) {
          logger.warn('Call Store: Answer already in progress');
          return;
        }

        set({ isAnswering: true, isLoading: true, error: null });

        try {
          logger.debug('Call Store: Answering call:', callId);
          const call = await callService.answerCall(callId);

          toastHelper.success('Call connected!');

          set({
            activeCall: call,
            incomingCall: null,
            isLoading: false,
            isAnswering: false,
          });

          logger.success('Call Store: Call answered:', call.id);
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to answer call';

          logger.error('Call Store: Answer call failed:', error);
          toastHelper.error(errorMsg);

          set({
            error: errorMsg,
            isLoading: false,
            isAnswering: false,
          });
          throw error;
        }
      },

      // Reject call
      rejectCall: async (callId) => {
        const state = get();

        if (state.isRejecting) {
          logger.warn('Call Store: Reject already in progress');
          return;
        }

        set({ isRejecting: true });

        try {
          logger.debug('Call Store: Rejecting call:', callId);
          await callService.rejectCall(callId);

          toastHelper.success('Call rejected');

          set({
            incomingCall: null,
            isRejecting: false,
          });

          logger.success('Call Store: Call rejected');
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to reject call';

          logger.error('Call Store: Reject call failed:', error);
          toastHelper.error(errorMsg);

          set({
            error: errorMsg,
            isRejecting: false,
          });
          throw error;
        }
      },

      // End call
      endCall: async (callId, duration) => {
        const state = get();

        if (state.isEnding) {
          logger.warn('Call Store: End already in progress');
          return;
        }

        set({ isEnding: true });

        try {
          logger.debug('Call Store: Ending call:', callId, 'duration:', duration);

          // Cleanup streams first
          get().cleanupStreams();

          await callService.endCall(callId, duration);

          toastHelper.success('Call ended');

          set({
            activeCall: null,
            incomingCall: null,
            isConnected: false,
            connectionState: 'closed',
            isEnding: false,
          });

          logger.success('Call Store: Call ended');
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to end call';

          logger.error('Call Store: End call failed:', error);

          // Still cleanup even on error
          get().cleanupStreams();

          set({
            activeCall: null,
            incomingCall: null,
            error: errorMsg,
            isEnding: false,
          });
        }
      },

      // Set incoming call
      setIncomingCall: (call) => {
        const state = get();

        // Don't set if already in a call
        if (call && state.activeCall) {
          logger.warn('Call Store: Cannot set incoming call - already in a call');
          return;
        }

        logger.debug('Call Store: Setting incoming call:', call?.id);
        set({ incomingCall: call });
      },

      // Set active call
      setActiveCall: (call) => {
        logger.debug('Call Store: Setting active call:', call?.id);

        // If clearing active call, also reset connection state
        if (!call) {
          set({
            activeCall: null,
            isConnected: false,
            connectionState: 'new',
          });
        } else {
          set({ activeCall: call });
        }
      },

      // Fetch call history
      fetchCallHistory: async () => {
        set({ isLoading: true, error: null });
        try {
          logger.debug('Call Store: Fetching call history...');
          const history = await callService.getCallHistory();

          set({ callHistory: history, isLoading: false });

          logger.success('Call Store: Call history fetched:', history.length);
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to fetch call history';

          logger.error('Call Store: Fetch call history failed:', error);

          set({
            error: errorMsg,
            isLoading: false,
          });
        }
      },

      // Delete call log
      deleteCallLog: async (callId) => {
        try {
          logger.debug('Call Store: Deleting call log:', callId);
          await callService.deleteCallLog(callId);

          toastHelper.success('Call log deleted');

          set((state) => ({
            callHistory: state.callHistory.filter((c) => c.id !== callId),
          }));

          logger.success('Call Store: Call log deleted');
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to delete call log';

          logger.error('Call Store: Delete call log failed:', error);
          toastHelper.error(errorMsg);

          set({ error: errorMsg });
          throw error;
        }
      },

      // Set local stream
      setLocalStream: (stream) => {
        logger.debug('Call Store: Setting local stream:', stream ? 'present' : 'null');
        set({ localStream: stream });
      },

      // Set remote stream
      setRemoteStream: (stream) => {
        logger.debug('Call Store: Setting remote stream:', stream ? 'present' : 'null');
        set({ remoteStream: stream });
      },

      // Set connection status
      setIsConnected: (connected) => {
        logger.debug('Call Store: Setting isConnected:', connected);
        set({ isConnected: connected });
      },

      // Set connection state
      setConnectionState: (state) => {
        logger.debug('Call Store: Setting connectionState:', state);
        set({ connectionState: state });
      },

      // Toggle mute
      toggleMute: () => {
        const { localStream, isMuted } = get();
        if (localStream) {
          localStream.getAudioTracks().forEach((track) => {
            track.enabled = isMuted; // If muted, enable. If not muted, disable.
          });

          logger.debug('Call Store: Toggled mute:', !isMuted);
          set({ isMuted: !isMuted });
        }
      },

      // Toggle video
      toggleVideo: () => {
        const { localStream, isVideoEnabled } = get();
        if (localStream) {
          localStream.getVideoTracks().forEach((track) => {
            track.enabled = !isVideoEnabled;
          });

          logger.debug('Call Store: Toggled video:', !isVideoEnabled);
          set({ isVideoEnabled: !isVideoEnabled });
        }
      },

      // Cleanup streams
      cleanupStreams: () => {
        const { localStream, remoteStream } = get();

        logger.debug('Call Store: Cleaning up streams...');

        if (localStream) {
          localStream.getTracks().forEach((track) => {
            track.stop();
            logger.debug('Call Store: Stopped local track:', track.kind);
          });
        }

        if (remoteStream) {
          remoteStream.getTracks().forEach((track) => {
            track.stop();
            logger.debug('Call Store: Stopped remote track:', track.kind);
          });
        }

        set({
          localStream: null,
          remoteStream: null,
          isMuted: false,
          isVideoEnabled: true,
          isConnected: false,
          connectionState: 'closed',
        });

        logger.debug('Call Store: Streams cleaned up');
      },

      // Clear error
      clearError: () => {
        set({ error: null });
      },

      // Reset store
      reset: () => {
        get().cleanupStreams();

        logger.debug('Call Store: Reset');

        set({
          activeCall: null,
          incomingCall: null,
          callHistory: [],
          isLoading: false,
          error: null,
          localStream: null,
          remoteStream: null,
          isMuted: false,
          isVideoEnabled: true,
          isConnected: false,
          connectionState: 'new',
          isAnswering: false,
          isRejecting: false,
          isEnding: false,
          isInitiating: false,
        });
      },
    }),
    { name: 'CallStore' }
  )
);

================================================
FILE: src/features/call/types/call.types.ts
================================================

// ================================================
// FILE: src/features/call/types/call.types.ts
// Call Types - Call related types
// ================================================

import type { User } from '@/shared/types/user-types';

// Call Type
export enum CallType {
  VOICE = 'VOICE',
  VIDEO = 'VIDEO',
}

// Call Status
export enum CallStatus {
  INITIATED = 'INITIATED',
  RINGING = 'RINGING',
  ANSWERED = 'ANSWERED',
  ENDED = 'ENDED',
  MISSED = 'MISSED',
  REJECTED = 'REJECTED',
  BUSY = 'BUSY',
}

// Base Call
export interface Call {
  id: string;
  callerId: string;
  receiverId: string;
  type: CallType | 'VOICE' | 'VIDEO';
  status: CallStatus | string;
  duration: number;
  startedAt: string | null;
  endedAt: string | null;
  createdAt: string;
  updatedAt: string;
}

// Call with user details
export interface CallWithDetails extends Call {
  caller: {
    id: string;
    name: string;
    username: string | null;
    avatar: string | null;
    profilePhoto: string | null;
  };
  receiver: {
    id: string;
    name: string;
    username: string | null;
    avatar: string | null;
    profilePhoto: string | null;
  };
}

// Initiate Call Input
export interface InitiateCallInput {
  receiverId: string;
  type: CallType | 'VOICE' | 'VIDEO';
}

// WebRTC Signal
export interface WebRTCSignal {
  callId: string;
  signal: RTCSessionDescriptionInit | RTCIceCandidateInit;
  to: string;
}

================================================
FILE: src/features/chat/components/index.ts
================================================

// ================================================
// FILE: src/features/chat/components/index.ts
// Export chat components
// ================================================

export { ChatList } from './chat-list';
export { ChatListItem } from './chat-list-item';
export { MessageBubble } from './message-bubble';
export { ChatInput } from './chat-input';
export { ChatRoom } from './chat-room';
export { NewChatModal } from './new-chat-modal';

================================================
FILE: src/features/chat/components/chat-input.tsx
================================================

// ================================================
// FILE: src/features/chat/components/chat-input.tsx
// ChatInput Component - Message input with media
// ================================================

import { useState, useRef, KeyboardEvent } from 'react';
import { Send, Image, Smile } from 'lucide-react';
import { Button } from '@/shared/components/ui/button';
import { Textarea } from '@/shared/components/ui/textarea';
import { cn } from '@/shared/utils/cn';

interface ChatInputProps {
  onSend: (content: string, type?: string, image?: string) => void;
  onTyping?: (chatId: string) => void; // FIXED: Accept chatId parameter
  onStopTyping?: (chatId: string) => void; // FIXED: Accept chatId parameter
  disabled?: boolean;
  placeholder?: string;
  chatId?: string; // ADD: chatId prop
}

export const ChatInput = ({
  onSend,
  onTyping,
  onStopTyping,
  disabled,
  placeholder = 'Type a message...',
  chatId = '', // ADD: default value
}: ChatInputProps) => {
  const [message, setMessage] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const typingTimeoutRef = useRef<number | null>(null);

  const handleChange = (value: string) => {
    setMessage(value);

    // Trigger typing indicator
    if (!isTyping && value.length > 0) {
      setIsTyping(true);
      onTyping?.(chatId); // FIXED: Pass chatId
    }

    // Clear previous timeout
    if (typingTimeoutRef.current !== null) {
      window.clearTimeout(typingTimeoutRef.current);
    }

    // Stop typing after 2 seconds of inactivity
    typingTimeoutRef.current = window.setTimeout(() => {
      setIsTyping(false);
      onStopTyping?.(chatId); // FIXED: Pass chatId
    }, 2000);
  };

  const handleSend = () => {
    const trimmed = message.trim();
    if (!trimmed || disabled) return;

    onSend(trimmed);
    setMessage('');
    setIsTyping(false);
    onStopTyping?.(chatId); // FIXED: Pass chatId

    // Focus back to textarea
    textareaRef.current?.focus();
  };

  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    // Send on Enter (without Shift)
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  return (
    <div className="border-t bg-background p-4">
      <div className="flex items-end gap-2">
        {/* Media buttons */}
        <div className="flex gap-1">
          <Button
            type="button"
            variant="ghost"
            size="icon"
            disabled={disabled}
          >
            <Image className="h-5 w-5" />
          </Button>

          <Button
            type="button"
            variant="ghost"
            size="icon"
            disabled={disabled}
          >
            <Smile className="h-5 w-5" />
          </Button>
        </div>

        {/* Message input */}
        <Textarea
          ref={textareaRef}
          value={message}
          onChange={(e) => handleChange(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          disabled={disabled}
          className="min-h-[44px] max-h-32 resize-none"
          rows={1}
        />

        {/* Send button */}
        <Button
          type="button"
          size="icon"
          onClick={handleSend}
          disabled={disabled || !message.trim()}
          className={cn(
            'shrink-0',
            message.trim() && 'bg-primary hover:bg-primary/90'
          )}
        >
          <Send className="h-5 w-5" />
        </Button>
      </div>
    </div>
  );
};

================================================
FILE: src/features/chat/components/chat-list.tsx
================================================

// ================================================
// FILE: src/features/chat/components/chat-list.tsx
// ChatList Component - Display list of chats
// ================================================

import { useNavigate } from 'react-router-dom';
import { MessageCircle } from 'lucide-react';
import { ChatListItem } from './chat-list-item';
import { EmptyState } from '@/shared/components/common/empty-state';
import { LoadingSpinner } from '@/shared/components/common/loading-spinner';
import { Button } from '@/shared/components/ui/button';
import { buildRoute } from '@/shared/constants/route-paths';
import type { ChatWithDetails } from '../types/chat.types';

interface ChatListProps {
  chats: ChatWithDetails[];
  isLoading?: boolean;
  onNewChat?: () => void;
}

export const ChatList = ({ chats, isLoading, onNewChat }: ChatListProps) => {
  const navigate = useNavigate();

  if (isLoading) {
    return (
      <div className="flex h-full items-center justify-center">
        <LoadingSpinner text="Loading chats..." />
      </div>
    );
  }

  if (chats.length === 0) {
    return (
      <EmptyState
        icon={MessageCircle}
        title="No chats yet"
        description="Start a conversation with your contacts"
        action={
          onNewChat && (
            <Button onClick={onNewChat}>
              Start New Chat
            </Button>
          )
        }
      />
    );
  }

  return (
    <div className="divide-y">
      {chats.map((chat) => (
        <ChatListItem
          key={chat.id}
          chat={chat}
          onClick={() => navigate(buildRoute.chatDetail(chat.id))}
        />
      ))}
    </div>
  );
};

================================================
FILE: src/features/chat/components/chat-list-item.tsx
================================================

// ================================================
// FILE: src/features/chat/components/chat-list-item.tsx
// ChatListItem Component - Single chat item in list
// ================================================

import { UserAvatar } from '@/shared/components/common/user-avatar';
import { dateFormatter } from '@/shared/utils/date-formatter';
import { stringHelper } from '@/shared/utils/string-helper';
import { cn } from '@/shared/utils/cn';
import { useAuthStore } from '@/features/auth/store/auth.store';
import type { ChatWithDetails } from '../types/chat.types';

interface ChatListItemProps {
  chat: ChatWithDetails;
  onClick?: () => void;
  active?: boolean;
}

export const ChatListItem = ({ chat, onClick, active }: ChatListItemProps) => {
  const { user: currentUser } = useAuthStore();

  // Get other participant (for 1-on-1 chat)
  const otherParticipant = chat.participants.find(
    (p) => p.id !== currentUser?.id
  );

  const lastMessage = chat.messages?.[0];
  const displayName = chat.isGroup
    ? chat.groupName
    : otherParticipant?.name || 'Unknown';

  const displayAvatar = chat.isGroup
    ? chat.groupAvatar
    : otherParticipant?.avatar;

  return (
    <div
      onClick={onClick}
      className={cn(
        'flex cursor-pointer items-center gap-3 p-4 transition-colors hover:bg-muted/50',
        active && 'bg-muted'
      )}
    >
      <UserAvatar
        src={displayAvatar}
        name={displayName || 'Chat'}
        size="lg"
        online={otherParticipant?.isOnline}
      />

      <div className="flex-1 overflow-hidden">
        <div className="flex items-center justify-between gap-2">
          <h4 className="truncate font-semibold text-foreground">
            {displayName}
          </h4>

          {lastMessage && (
            <span className="text-xs text-muted-foreground">
              {dateFormatter.chatListTime(lastMessage.createdAt)}
            </span>
          )}
        </div>

        {lastMessage && (
          <p className="truncate text-sm text-muted-foreground">
            {lastMessage.type === 'text'
              ? stringHelper.truncate(lastMessage.content, 50)
              : `${lastMessage.type.charAt(0).toUpperCase() + lastMessage.type.slice(1)}`
            }
          </p>
        )}
      </div>

      {lastMessage && !lastMessage.read && (
        <div className="h-2 w-2 rounded-full bg-primary" />
      )}
    </div>
  );
};

================================================
FILE: src/features/chat/components/chat-room.tsx
================================================

// ================================================
// FILE: src/features/chat/components/chat-room.tsx
// ChatRoom Component - Single chat room view (WITH CALL BUTTONS)
// ================================================

import { useEffect, useRef } from 'react';
import { ArrowLeft, Phone, Video, MoreVertical } from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import { Button } from '@/shared/components/ui/button';
import { UserAvatar } from '@/shared/components/common/user-avatar';
import { MessageBubble } from './message-bubble';
import { ChatInput } from './chat-input';
import { LoadingSpinner } from '@/shared/components/common/loading-spinner';
import { useChat } from '../hooks/use-chat';
import { useCall } from '@/features/call/hooks/use-call'; // ‚úÖ IMPORT CALL HOOK
import { useAuthStore } from '@/features/auth/store/auth.store';
import { ROUTE_PATHS } from '@/shared/constants/route-paths';
import { CallType } from '@/features/call/types/call.types'; // ‚úÖ IMPORT CALL TYPE
import { logger } from '@/shared/utils/logger';

export const ChatRoom = () => {
  const navigate = useNavigate();
  const { user } = useAuthStore();
  const {
    activeChat,
    messages,
    isLoading,
    sendMessage,
    startTyping,
    stopTyping
  } = useChat();

  // ‚úÖ ADD: Call hook
  const { initiateCall } = useCall();

  const messagesEndRef = useRef<HTMLDivElement>(null);

  // Auto scroll to bottom
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  if (isLoading) {
    return (
      <div className="flex h-full items-center justify-center">
        <LoadingSpinner text="Loading messages..." />
      </div>
    );
  }

  if (!activeChat) {
    return null;
  }

  const otherParticipant = activeChat.participants.find(
    (p) => p.id !== user?.id
  );

  const displayName = activeChat.isGroup
    ? activeChat.groupName
    : otherParticipant?.name || 'Unknown';

  // ‚úÖ ADD: Handle voice call
  const handleVoiceCall = async () => {
    if (!otherParticipant) {
      logger.error('ChatRoom: Cannot initiate call - No participant found');
      return;
    }

    try {
      logger.debug('ChatRoom: Initiating voice call to:', otherParticipant.name);

      await initiateCall({
        receiverId: otherParticipant.id,
        type: CallType.VOICE,
      });

      logger.success('ChatRoom: Voice call initiated');
    } catch (error) {
      logger.error('ChatRoom: Failed to initiate voice call:', error);
    }
  };

  // ‚úÖ ADD: Handle video call
  const handleVideoCall = async () => {
    if (!otherParticipant) {
      logger.error('ChatRoom: Cannot initiate call - No participant found');
      return;
    }

    try {
      logger.debug('ChatRoom: Initiating video call to:', otherParticipant.name);

      await initiateCall({
        receiverId: otherParticipant.id,
        type: CallType.VIDEO,
      });

      logger.success('ChatRoom: Video call initiated');
    } catch (error) {
      logger.error('ChatRoom: Failed to initiate video call:', error);
    }
  };

  return (
    <div className="flex h-full flex-col">
      {/* Header */}
      <div className="flex items-center gap-3 border-b bg-background p-4">
        <Button
          variant="ghost"
          size="icon"
          onClick={() => navigate(ROUTE_PATHS.CHATS)}
          className="lg:hidden"
        >
          <ArrowLeft className="h-5 w-5" />
        </Button>

        <UserAvatar
          src={activeChat.isGroup ? activeChat.groupAvatar : otherParticipant?.avatar}
          name={displayName || 'Chat'}
          size="md"
          online={otherParticipant?.isOnline}
        />

        <div className="flex-1">
          <h2 className="font-semibold">{displayName}</h2>
          {otherParticipant?.isOnline && (
            <p className="text-sm text-green-500">Online</p>
          )}
        </div>

        {/* ‚úÖ FIXED: Call buttons with actual functionality */}
        <div className="flex gap-1">
          <Button
            variant="ghost"
            size="icon"
            onClick={handleVoiceCall}
            disabled={activeChat.isGroup} // ‚úÖ Disable for group chats
            title="Voice Call"
          >
            <Phone className="h-5 w-5" />
          </Button>

          <Button
            variant="ghost"
            size="icon"
            onClick={handleVideoCall}
            disabled={activeChat.isGroup} // ‚úÖ Disable for group chats
            title="Video Call"
          >
            <Video className="h-5 w-5" />
          </Button>

          <Button variant="ghost" size="icon">
            <MoreVertical className="h-5 w-5" />
          </Button>
        </div>
      </div>

      {/* Messages */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map((message) => (
          <MessageBubble
            key={message.id}
            message={message}
            isOwn={message.senderId === user?.id}
          />
        ))}
        <div ref={messagesEndRef} />
      </div>

      {/* Input */}
      <ChatInput
        onSend={(content) => sendMessage(content)}
        onTyping={startTyping}
        onStopTyping={stopTyping}
        chatId={activeChat.id}
      />
    </div>
  );
};

================================================
FILE: src/features/chat/components/message-bubble.tsx
================================================

// ================================================
// FILE: src/features/chat/components/message-bubble.tsx
// MessageBubble Component - Single message bubble
// ================================================

import { UserAvatar } from '@/shared/components/common/user-avatar';
import { dateFormatter } from '@/shared/utils/date-formatter';
import { cn } from '@/shared/utils/cn';
import { Check, CheckCheck } from 'lucide-react';
import type { MessageWithDetails } from '../types/chat.types';

interface MessageBubbleProps {
  message: MessageWithDetails;
  isOwn: boolean;
  showAvatar?: boolean;
  showTimestamp?: boolean;
}

export const MessageBubble = ({
  message,
  isOwn,
  showAvatar = true,
  showTimestamp = true,
}: MessageBubbleProps) => {
  return (
    <div
      className={cn(
        'flex gap-2',
        isOwn ? 'flex-row-reverse' : 'flex-row'
      )}
    >
      {showAvatar && !isOwn && (
        <UserAvatar
          src={message.sender.avatar}
          name={message.sender.name}
          size="sm"
        />
      )}

      <div
        className={cn(
          'flex max-w-[70%] flex-col gap-1',
          isOwn && 'items-end'
        )}
      >
        {/* Reply To */}
        {message.replyTo && (
          <div className={cn(
            'rounded-lg border-l-4 bg-muted/50 px-3 py-2 text-xs',
            isOwn ? 'border-primary' : 'border-muted-foreground'
          )}>
            <p className="font-semibold text-foreground">
              {message.replyTo.sender.name}
            </p>
            <p className="truncate text-muted-foreground">
              {message.replyTo.content}
            </p>
          </div>
        )}

        {/* Message Content */}
        <div
          className={cn(
            'rounded-2xl px-4 py-2',
            isOwn
              ? 'bg-primary text-primary-foreground'
              : 'bg-muted text-foreground'
          )}
        >
          {message.type === 'image' && message.image && (
            <img
              src={message.image}
              alt="Message"
              className="mb-2 max-h-64 rounded-lg object-cover"
            />
          )}

          <p className="break-words text-sm">
            {message.content}
          </p>

          {showTimestamp && (
            <div className={cn(
              'mt-1 flex items-center gap-1 text-xs',
              isOwn ? 'justify-end text-primary-foreground/70' : 'text-muted-foreground'
            )}>
              <span>
                {dateFormatter.messageTime(message.createdAt)}
              </span>

              {isOwn && (
                message.read ? (
                  <CheckCheck className="h-3 w-3" />
                ) : (
                  <Check className="h-3 w-3" />
                )
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

================================================
FILE: src/features/chat/components/new-chat-modal.tsx
================================================

// ================================================
// FILE: src/features/chat/components/new-chat-modal.tsx
// NewChatModal Component - Start new chat
// ================================================

import { useState } from 'react';
import { MessageCircle, Loader2 } from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from '@/shared/components/ui/dialog';
import { Button } from '@/shared/components/ui/button';
import { UserAvatar } from '@/shared/components/common/user-avatar';
import { SearchBar } from '@/shared/components/common/search-bar';
import { LoadingSpinner } from '@/shared/components/common/loading-spinner';
import { EmptyState } from '@/shared/components/common/empty-state';
import { useChat } from '../hooks/use-chat';
import { useContactStore } from '@/features/contacts/store/contact.store';
import { buildRoute } from '@/shared/constants/route-paths';

interface NewChatModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export const NewChatModal = ({
  open,
  onOpenChange,
}: NewChatModalProps) => {
  const navigate = useNavigate();
  const { createChat, isLoading: isCreating } = useChat();
  const { contacts, isLoading: isLoadingContacts } = useContactStore();

  const [searchQuery, setSearchQuery] = useState('');

  // Filter contacts based on search
  const filteredContacts = contacts.filter((contact) =>
    contact.contact.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    contact.contact.username?.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const handleCreateChat = async (contactId: string) => {
    try {
      const chat = await createChat({ participantId: contactId });
      onOpenChange(false);
      navigate(buildRoute.chatDetail(chat.id));
    } catch (error) {
      console.error('Failed to create chat:', error);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-md max-h-[80vh] flex flex-col">
        <DialogHeader>
          <DialogTitle>New Chat</DialogTitle>
          <DialogDescription>
            Select a contact to start a conversation
          </DialogDescription>
        </DialogHeader>

        {/* Search Bar */}
        <SearchBar
          placeholder="Search contacts..."
          onSearch={setSearchQuery}
        />

        {/* Contacts List */}
        <div className="flex-1 overflow-y-auto -mx-6 px-6">
          {isLoadingContacts ? (
            <div className="flex items-center justify-center py-8">
              <LoadingSpinner text="Loading contacts..." />
            </div>
          ) : filteredContacts.length === 0 ? (
            <EmptyState
              icon={MessageCircle}
              title={searchQuery ? 'No contacts found' : 'No contacts yet'}
              description={
                searchQuery
                  ? 'Try searching with a different name'
                  : 'Add friends to start chatting'
              }
            />
          ) : (
            <div className="space-y-2">
              {filteredContacts.map((contact) => (
                <button
                  key={contact.id}
                  onClick={() => handleCreateChat(contact.contactId)}
                  disabled={isCreating}
                  className="w-full flex items-center gap-3 p-3 rounded-lg transition-colors hover:bg-muted/50 disabled:opacity-50"
                >
                  <UserAvatar
                    src={contact.contact.avatar}
                    name={contact.contact.name}
                    size="md"
                    online={contact.contact.isOnline}
                  />

                  <div className="flex-1 overflow-hidden text-left">
                    <h4 className="truncate font-semibold text-foreground">
                      {contact.nickname || contact.contact.name}
                    </h4>

                    {contact.nickname && (
                      <p className="truncate text-sm text-muted-foreground">
                        {contact.contact.name}
                      </p>
                    )}

                    {contact.contact.username && (
                      <p className="truncate text-xs text-muted-foreground">
                        @{contact.contact.username}
                      </p>
                    )}
                  </div>

                  {isCreating && (
                    <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
                  )}
                </button>
              ))}
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
};

================================================
FILE: src/features/chat/hooks/use-chat.ts
================================================

// ================================================
// FILE: src/features/chat/hooks/use-chat.ts
// USE GLOBAL FLAG OUTSIDE REACT (CLEANED)
// ================================================

import { useEffect, useMemo } from 'react';
import { useChatStore } from '../store/chat.store';
import { useChatSocket } from './use-chat-socket';
import { logger } from '@/shared/utils/logger';
import type { CreateChatInput } from '../types/chat.types';

// ‚úÖ GLOBAL FLAG (outside React component lifecycle)
let GLOBAL_CHATS_FETCHED = false;

export const useChat = (chatId?: string) => {
  const {
    chats,
    activeChat,
    messages,
    isLoading,
    error,
    typingUsers,
    fetchChats,
    setActiveChat,
    createChat,
    deleteChat,
    fetchMessages,
    deleteMessage,
    clearError,
  } = useChatStore();

  const { sendMessage, startTyping, stopTyping } = useChatSocket();

  // ‚úÖ Fetch chats ONLY ONCE using GLOBAL flag
  useEffect(() => {
    if (!GLOBAL_CHATS_FETCHED) {
      logger.debug('useChat: Fetching chats (first time only)');
      fetchChats();
      GLOBAL_CHATS_FETCHED = true;
    }
  }, [fetchChats]);

  // Set active chat when chatId changes
  useEffect(() => {
    if (chatId) {
      const chat = chats.find((c) => c.id === chatId);
      if (chat) {
        setActiveChat(chat);
      }
    }
  }, [chatId, chats, setActiveChat]);

  // Get messages for active chat
  const chatMessages = useMemo(() => {
    return activeChat ? messages[activeChat.id] || [] : [];
  }, [activeChat, messages]);

  // Get typing users for active chat
  const typingUsersList = useMemo(() => {
    return activeChat ? typingUsers[activeChat.id] || [] : [];
  }, [activeChat, typingUsers]);

  // Create new chat
  const handleCreateChat = async (data: CreateChatInput) => {
    try {
      logger.debug('useChat: Creating chat...');
      const chat = await createChat(data);
      setActiveChat(chat);
      return chat;
    } catch (error) {
      logger.error('useChat: Failed to create chat:', error);
      throw error;
    }
  };

  // Send message
  const handleSendMessage = (content: string, type: string = 'text', image?: string) => {
    if (!activeChat) return;

    sendMessage({
      chatId: activeChat.id,
      content,
      type,
      image,
    });
  };

  // Delete chat
  const handleDeleteChat = async (chatIdToDelete: string) => {
    try {
      logger.debug('useChat: Deleting chat:', chatIdToDelete);
      await deleteChat(chatIdToDelete);
    } catch (error) {
      logger.error('useChat: Failed to delete chat:', error);
      throw error;
    }
  };

  // Delete message
  const handleDeleteMessage = async (messageId: string) => {
    if (!activeChat) return;

    try {
      logger.debug('useChat: Deleting message:', messageId);
      await deleteMessage(messageId, activeChat.id);
    } catch (error) {
      logger.error('useChat: Failed to delete message:', error);
      throw error;
    }
  };

  return {
    chats,
    activeChat,
    messages: chatMessages,
    typingUsers: typingUsersList,
    isLoading,
    error,
    createChat: handleCreateChat,
    sendMessage: handleSendMessage,
    deleteChat: handleDeleteChat,
    deleteMessage: handleDeleteMessage,
    startTyping,
    stopTyping,
    clearError,
  };
};

// ‚úÖ EXPORT: Reset function for logout
export const resetChatFetch = () => {
  GLOBAL_CHATS_FETCHED = false;
};

================================================
FILE: src/features/chat/hooks/use-chat-socket.ts
================================================

// ================================================
// FILE: src/features/chat/hooks/use-chat-socket.ts
// useChatSocket - Only for EMITTING (CLEANED)
// ================================================

import { useCallback } from 'react';
import { socketClient } from '@/lib/socket-client';
import { SOCKET_EVENTS } from '@/shared/constants/socket-events';
import { toastHelper } from '@/shared/utils/toast-helper';
import { logger } from '@/shared/utils/logger';

export const useChatSocket = () => {
  // ‚úÖ ONLY EMIT FUNCTIONS, NO LISTENERS!

  // Send message via socket
  const sendMessage = useCallback((data: {
    chatId: string;
    content: string;
    type?: string;
    image?: string;
    replyToId?: string;
  }) => {
    if (!socketClient.isConnected()) {
      logger.error('useChatSocket: Cannot send message - Socket not connected');
      toastHelper.error('Not connected to server');
      return;
    }

    logger.debug('useChatSocket: Sending message to chat:', data.chatId);
    socketClient.emit(SOCKET_EVENTS.MESSAGE_SEND, data);
  }, []);

  // Start typing
  const startTyping = useCallback((chatId: string) => {
    if (socketClient.isConnected()) {
      logger.debug('useChatSocket: Start typing in chat:', chatId);
      socketClient.emit(SOCKET_EVENTS.TYPING_START, { chatId });
    }
  }, []);

  // Stop typing
  const stopTyping = useCallback((chatId: string) => {
    if (socketClient.isConnected()) {
      logger.debug('useChatSocket: Stop typing in chat:', chatId);
      socketClient.emit(SOCKET_EVENTS.TYPING_STOP, { chatId });
    }
  }, []);

  return {
    sendMessage,
    startTyping,
    stopTyping,
  };
};

================================================
FILE: src/features/chat/pages/chat-page.tsx
================================================

// ================================================
// FILE: src/features/chat/pages/chat-page.tsx
// ChatPage - Main chat page with list and room (UPDATED)
// ================================================

import { useState } from 'react';
import { useParams } from 'react-router-dom';
import { Plus } from 'lucide-react';
import { AppLayout } from '@/shared/components/layouts/app-layout';
import { ChatLayout } from '@/shared/components/layouts/chat-layout';
import { SearchBar } from '@/shared/components/common/search-bar';
import { Button } from '@/shared/components/ui/button';
import { ChatList } from '../components/chat-list';
import { ChatRoom } from '../components/chat-room';
import { NewChatModal } from '../components/new-chat-modal';
import { useChat } from '../hooks/use-chat';

export const ChatPage = () => {
  const { chatId } = useParams();
  const { chats, isLoading } = useChat(chatId);
  const [searchQuery, setSearchQuery] = useState('');
  const [showNewChatModal, setShowNewChatModal] = useState(false);

  const filteredChats = chats.filter((chat) => {
    const searchLower = searchQuery.toLowerCase();
    // Filter by participant name or group name
    return chat.participants.some((p) =>
      p.name.toLowerCase().includes(searchLower)
    ) || chat.groupName?.toLowerCase().includes(searchLower);
  });

  const sidebar = (
    <div className="flex h-full flex-col">
      {/* Header */}
      <div className="border-b p-4">
        <div className="flex items-center justify-between mb-3">
          <h1 className="text-2xl font-bold">Chats</h1>
          <Button
            size="icon"
            variant="ghost"
            onClick={() => setShowNewChatModal(true)}
          >
            <Plus className="h-5 w-5" />
          </Button>
        </div>

        <SearchBar
          placeholder="Search chats..."
          onSearch={setSearchQuery}
        />
      </div>

      {/* Chat List */}
      <div className="flex-1 overflow-y-auto">
        <ChatList
          chats={filteredChats}
          isLoading={isLoading}
          onNewChat={() => setShowNewChatModal(true)}
        />
      </div>
    </div>
  );

  const main = chatId ? (
    <ChatRoom />
  ) : (
    <div className="flex h-full items-center justify-center text-center p-4">
      <div>
        <h2 className="text-xl font-semibold mb-2">Select a chat</h2>
        <p className="text-muted-foreground mb-4">
          Choose a conversation from the list to start messaging
        </p>
        <Button onClick={() => setShowNewChatModal(true)}>
          <Plus className="mr-2 h-4 w-4" />
          Start New Chat
        </Button>
      </div>
    </div>
  );

  return (
    <AppLayout>
      <ChatLayout
        sidebar={sidebar}
        main={main}
        showSidebar={!chatId}
      />

      {/* New Chat Modal */}
      <NewChatModal
        open={showNewChatModal}
        onOpenChange={setShowNewChatModal}
      />
    </AppLayout>
  );
};

================================================
FILE: src/features/chat/services/chat.service.ts
================================================

// ================================================
// FILE: src/features/chat/services/chat.service.ts
// Chat Service - Handle all chat API calls (CLEANED)
// ================================================

import { axiosClient } from '@/lib/axios-client';
import { API_ENDPOINTS } from '@/shared/constants/api-endpoints';
import { logger } from '@/shared/utils/logger';
import type { ApiResponse } from '@/shared/types/api-types';
import type {
  Chat,
  CreateChatInput,
  ChatWithDetails
} from '../types/chat.types';

export const chatService = {
  // Get all user chats
  getUserChats: async (): Promise<ChatWithDetails[]> => {
    logger.debug('Chat Service: Getting user chats...');
    const response = await axiosClient.get<ApiResponse<ChatWithDetails[]>>(
      API_ENDPOINTS.CHAT.LIST
    );
    logger.success('Chat Service: User chats retrieved');
    return response.data.data || [];
  },

  // Get chat by ID
  getChatById: async (chatId: string): Promise<ChatWithDetails> => {
    logger.debug('Chat Service: Getting chat by ID:', chatId);
    const response = await axiosClient.get<ApiResponse<ChatWithDetails>>(
      API_ENDPOINTS.CHAT.BY_ID(chatId)
    );
    logger.success('Chat Service: Chat retrieved');
    return response.data.data!;
  },

  // Create new chat
  createChat: async (data: CreateChatInput): Promise<ChatWithDetails> => {
    logger.debug('Chat Service: Creating chat...');
    const response = await axiosClient.post<ApiResponse<ChatWithDetails>>(
      API_ENDPOINTS.CHAT.CREATE,
      data
    );
    logger.success('Chat Service: Chat created');
    return response.data.data!;
  },

  // Delete chat
  deleteChat: async (chatId: string): Promise<void> => {
    logger.debug('Chat Service: Deleting chat:', chatId);
    await axiosClient.delete(API_ENDPOINTS.CHAT.DELETE(chatId));
    logger.success('Chat Service: Chat deleted');
  },
};

================================================
FILE: src/features/chat/services/message.service.ts
================================================

// ================================================
// FILE: src/features/chat/services/message.service.ts
// Message Service - Handle all message API calls (CLEANED)
// ================================================

import { API_ENDPOINTS } from '@/shared/constants/api-endpoints';
import type { ApiResponse } from '@/shared/types/api-types';
import type {
  Message,
  CreateMessageInput,
  MessageWithDetails
} from '../types/chat.types';
import { logger } from '@/shared/utils/logger';
import { axiosClient } from '@/lib/axios-client';

export const messageService = {
  // Get messages by chat ID
  getChatMessages: async (chatId: string): Promise<MessageWithDetails[]> => {
    logger.debug('Message Service: Getting messages for chat:', chatId);
    const response = await axiosClient.get<ApiResponse<MessageWithDetails[]>>(
      API_ENDPOINTS.MESSAGE.BY_CHAT(chatId)
    );
    logger.success('Message Service: Messages retrieved');
    return response.data.data || [];
  },

  // Send message (HTTP fallback)
  sendMessage: async (data: CreateMessageInput): Promise<MessageWithDetails> => {
    logger.debug('Message Service: Sending message...');
    const response = await axiosClient.post<ApiResponse<MessageWithDetails>>(
      API_ENDPOINTS.MESSAGE.SEND,
      data
    );
    logger.success('Message Service: Message sent');
    return response.data.data!;
  },

  // Delete message
  deleteMessage: async (messageId: string): Promise<void> => {
    logger.debug('Message Service: Deleting message:', messageId);
    await axiosClient.delete(API_ENDPOINTS.MESSAGE.DELETE(messageId));
    logger.success('Message Service: Message deleted');
  },

  // Mark message as read
  markAsRead: async (messageId: string): Promise<void> => {
    logger.debug('Message Service: Marking message as read:', messageId);
    await axiosClient.patch(API_ENDPOINTS.MESSAGE.MARK_READ(messageId));
    logger.success('Message Service: Message marked as read');
  },
};

================================================
FILE: src/features/chat/store/chat.store.ts
================================================

// ================================================
// FILE: src/features/chat/store/chat.store.ts
// Chat Store - Global chat & message state (CLEANED)
// ================================================

import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { chatService } from '../services/chat.service';
import { messageService } from '../services/message.service';
import { toastHelper } from '@/shared/utils/toast-helper';
import { logger } from '@/shared/utils/logger';
import type {
  ChatWithDetails,
  MessageWithDetails,
  CreateChatInput,
  CreateMessageInput
} from '../types/chat.types';

interface ChatState {
  // State
  chats: ChatWithDetails[];
  activeChat: ChatWithDetails | null;
  messages: Record<string, MessageWithDetails[]>; // { chatId: messages[] }
  isLoading: boolean;
  error: string | null;
  hasFetchedChats: boolean;

  // Actions - Chat
  fetchChats: () => Promise<void>;
  setActiveChat: (chat: ChatWithDetails | null) => void;
  createChat: (data: CreateChatInput) => Promise<ChatWithDetails>;
  deleteChat: (chatId: string) => Promise<void>;
  addChat: (chat: ChatWithDetails) => void;
  updateChat: (chatId: string, updates: Partial<ChatWithDetails>) => void;

  // Actions - Message
  fetchMessages: (chatId: string) => Promise<void>;
  sendMessage: (data: CreateMessageInput) => Promise<void>;
  addMessage: (message: MessageWithDetails) => void;
  deleteMessage: (messageId: string, chatId: string) => Promise<void>;
  updateMessage: (messageId: string, chatId: string, updates: Partial<MessageWithDetails>) => void;

  // Typing indicators
  typingUsers: Record<string, string[]>; // { chatId: [userId1, userId2] }
  setTyping: (chatId: string, userId: string, isTyping: boolean) => void;

  // Utils
  clearError: () => void;
  reset: () => void;
}

export const useChatStore = create<ChatState>()(
  devtools(
    (set, get) => ({
      // Initial state
      chats: [],
      activeChat: null,
      messages: {},
      isLoading: false,
      error: null,
      typingUsers: {},
      hasFetchedChats: false,

      // Fetch all chats
      fetchChats: async () => {
        set({ isLoading: true, error: null });

        try {
          logger.debug('Chat Store: Fetching chats...');
          const chats = await chatService.getUserChats();

          set({
            chats,
            isLoading: false,
            hasFetchedChats: true
          });

          logger.success('Chat Store: Chats fetched:', chats.length);
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to fetch chats';

          logger.error('Chat Store: Fetch chats failed:', error);

          set({
            error: errorMsg,
            isLoading: false
          });

          // Silent error - no toast for background fetch
        }
      },

      // Set active chat
      setActiveChat: (chat) => {
        set({ activeChat: chat });
        if (chat && !get().messages[chat.id]) {
          get().fetchMessages(chat.id);
        }
      },

      // Create new chat
      createChat: async (data) => {
        try {
          logger.debug('Chat Store: Creating chat...');
          const chat = await chatService.createChat(data);

          toastHelper.success('Chat created successfully!');

          set((state) => ({
            chats: [chat, ...state.chats]
          }));

          logger.success('Chat Store: Chat created');
          return chat;
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to create chat';

          logger.error('Chat Store: Create chat failed:', error);
          toastHelper.error(errorMsg);

          set({ error: errorMsg });
          throw error;
        }
      },

      // Delete chat
      deleteChat: async (chatId) => {
        try {
          logger.debug('Chat Store: Deleting chat:', chatId);
          await chatService.deleteChat(chatId);

          toastHelper.success('Chat deleted successfully!');

          set((state) => ({
            chats: state.chats.filter((c) => c.id !== chatId),
            activeChat: state.activeChat?.id === chatId ? null : state.activeChat,
            messages: Object.fromEntries(
              Object.entries(state.messages).filter(([id]) => id !== chatId)
            ),
          }));

          logger.success('Chat Store: Chat deleted');
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to delete chat';

          logger.error('Chat Store: Delete chat failed:', error);
          toastHelper.error(errorMsg);

          set({ error: errorMsg });
          throw error;
        }
      },

      // Add chat (from socket)
      addChat: (chat) => {
        logger.debug('Chat Store: Adding chat from socket:', chat.id);

        set((state) => {
          const exists = state.chats.some((c) => c.id === chat.id);
          if (exists) return state;
          return { chats: [chat, ...state.chats] };
        });
      },

      // Update chat
      updateChat: (chatId, updates) => {
        logger.debug('Chat Store: Updating chat:', chatId);

        set((state) => ({
          chats: state.chats.map((chat) =>
            chat.id === chatId ? { ...chat, ...updates } : chat
          ),
          activeChat: state.activeChat?.id === chatId
            ? { ...state.activeChat, ...updates }
            : state.activeChat,
        }));
      },

      // Fetch messages for a chat
      fetchMessages: async (chatId) => {
        set({ isLoading: true, error: null });

        try {
          logger.debug('Chat Store: Fetching messages for chat:', chatId);
          const messages = await messageService.getChatMessages(chatId);

          set((state) => ({
            messages: { ...state.messages, [chatId]: messages },
            isLoading: false,
          }));

          logger.success('Chat Store: Messages fetched:', messages.length);
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to fetch messages';

          logger.error('Chat Store: Fetch messages failed:', error);

          set({
            error: errorMsg,
            isLoading: false
          });

          // Silent error - no toast for background fetch
        }
      },

      // Send message
      sendMessage: async (data) => {
        try {
          logger.debug('Chat Store: Sending message...');
          await messageService.sendMessage(data);
          // Message will be added via socket event
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to send message';

          logger.error('Chat Store: Send message failed:', error);
          toastHelper.error(errorMsg);

          set({ error: errorMsg });
          throw error;
        }
      },

      // Add message (from socket) - PREVENT DUPLICATES
      addMessage: (message) => {
        set((state) => {
          const chatMessages = state.messages[message.chatId] || [];

          // Check for duplicate
          const isDuplicate = chatMessages.some(m => m.id === message.id);
          if (isDuplicate) {
            logger.warn('Chat Store: Duplicate message prevented:', message.id);
            return state;
          }

          logger.debug('Chat Store: Adding message:', message.id);

          return {
            messages: {
              ...state.messages,
              [message.chatId]: [...chatMessages, message],
            },
          };
        });

        // Update chat's last message
        get().updateChat(message.chatId, {
          updatedAt: message.createdAt,
          messages: [message],
        } as any);
      },

      // Delete message
      deleteMessage: async (messageId, chatId) => {
        try {
          logger.debug('Chat Store: Deleting message:', messageId);
          await messageService.deleteMessage(messageId);

          toastHelper.success('Message deleted');

          set((state) => ({
            messages: {
              ...state.messages,
              [chatId]: state.messages[chatId]?.filter((m) => m.id !== messageId) || [],
            },
          }));

          logger.success('Chat Store: Message deleted');
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to delete message';

          logger.error('Chat Store: Delete message failed:', error);
          toastHelper.error(errorMsg);

          set({ error: errorMsg });
          throw error;
        }
      },

      // Update message
      updateMessage: (messageId, chatId, updates) => {
        logger.debug('Chat Store: Updating message:', messageId);

        set((state) => ({
          messages: {
            ...state.messages,
            [chatId]: state.messages[chatId]?.map((msg) =>
              msg.id === messageId ? { ...msg, ...updates } : msg
            ) || [],
          },
        }));
      },

      // Set typing indicator
      setTyping: (chatId, userId, isTyping) => {
        set((state) => {
          const users = state.typingUsers[chatId] || [];
          const filtered = users.filter((id) => id !== userId);

          return {
            typingUsers: {
              ...state.typingUsers,
              [chatId]: isTyping ? [...filtered, userId] : filtered,
            },
          };
        });
      },

      // Clear error
      clearError: () => {
        set({ error: null });
      },

      // Reset store
      reset: () => {
        set({
          chats: [],
          activeChat: null,
          messages: {},
          isLoading: false,
          error: null,
          typingUsers: {},
          hasFetchedChats: false,
        });
      },
    }),
    { name: 'ChatStore' }
  )
);

================================================
FILE: src/features/chat/types/chat.types.ts
================================================

// ================================================
// FILE: src/features/chat/types/chat.types.ts
// Chat Types - Chat & Message related types
// ================================================

import type { User } from '@/shared/types/user-types';

// Message Type
export type MessageType = 'text' | 'image' | 'video' | 'file' | 'audio';

// Base Chat
export interface Chat {
  id: string;
  isGroup: boolean;
  groupName: string | null;
  groupAvatar: string | null;
  createdById: string;
  createdAt: string;
  updatedAt: string;
}

// Chat with participants and last message
export interface ChatWithDetails extends Chat {
  participants: User[];
  messages: MessageWithDetails[];
}

// Base Message
export interface Message {
  id: string;
  content: string;
  type: MessageType;
  image: string | null;
  chatId: string;
  senderId: string;
  replyToId: string | null;
  read: boolean;
  createdAt: string;
  updatedAt: string;
}

// Message with sender details
export interface MessageWithDetails extends Message {
  sender: {
    id: string;
    name: string;
    avatar: string | null;
    email?: string;
    username?: string | null;
    createdAt?: string;
    updatedAt?: string;
  };
  replyTo?: MessageWithDetails | null;
  chat?: ChatWithDetails;
}

// Create Chat Input
export interface CreateChatInput {
  participantId: string;
}

// Create Message Input
export interface CreateMessageInput {
  chatId: string;
  content: string;
  type?: MessageType;
  image?: string;
  replyToId?: string;
}

// Typing Indicator
export interface TypingIndicator {
  userId: string;
  chatId: string;
  username: string;
  isTyping: boolean;
}

================================================
FILE: src/features/contacts/components/index.ts
================================================

// ================================================
// FILE: src/features/contacts/components/index.ts
// Export contact components
// ================================================

export { ContactList } from './contact-list';
export { ContactItem } from './contact-item';
export { FriendRequestItem } from './friend-request-item';
export { AddContactModal } from './add-contact-modal';

================================================
FILE: src/features/contacts/components/add-contact-modal.tsx
================================================

// ================================================
// FILE: src/features/contacts/components/add-contact-modal.tsx
// AddContactModal Component - Add new contact (CLEANED)
// ================================================

import { useState, useEffect } from 'react';
import { Search, UserPlus, Loader2, Users } from 'lucide-react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from '@/shared/components/ui/dialog';
import { Button } from '@/shared/components/ui/button';
import { Input } from '@/shared/components/ui/input';
import { UserAvatar } from '@/shared/components/common/user-avatar';
import { LoadingSpinner } from '@/shared/components/common/loading-spinner';
import { EmptyState } from '@/shared/components/common/empty-state';
import { useContacts } from '../hooks/use-contacts';
import { useAuthStore } from '@/features/auth/store/auth.store';
import { userService } from '@/features/user/services/user.service';
import { toastHelper } from '@/shared/utils/toast-helper';
import { logger } from '@/shared/utils/logger';
import type { User } from '@/shared/types/user-types';

interface AddContactModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export const AddContactModal = ({
  open,
  onOpenChange,
}: AddContactModalProps) => {
  const { user: currentUser } = useAuthStore();
  const { sendRequest, contacts } = useContacts();

  const [allUsers, setAllUsers] = useState<User[]>([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [sendingTo, setSendingTo] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);

  // Fetch all users when modal opens
  useEffect(() => {
    if (open) {
      fetchAllUsers();
    }
  }, [open]);

  const fetchAllUsers = async () => {
    setIsLoading(true);
    setError(null);

    try {
      logger.debug('Add Contact Modal: Fetching all users...');

      const response = await userService.getAllUsers();
      const users = Array.isArray(response) ? response : [];

      if (users.length === 0) {
        logger.warn('Add Contact Modal: No users returned from API');
        setError('No users found. Please make sure backend is returning user list.');
      }

      // Filter out current user and existing contacts
      const contactIds = contacts.map(c => c.contactId);
      const filteredUsers = users.filter(
        u => u.id !== currentUser?.id && !contactIds.includes(u.id)
      );

      logger.success('Add Contact Modal: Users fetched and filtered:', filteredUsers.length);

      setAllUsers(filteredUsers);

      if (filteredUsers.length === 0 && users.length > 0) {
        setError('All available users are already in your contacts.');
      }
    } catch (error: any) {
      logger.error('Add Contact Modal: Failed to fetch users:', error);

      const errorMsg = error.response?.data?.message ||
        error.message ||
        'Failed to load users. Please check backend connection.';

      setError(errorMsg);
      toastHelper.error(errorMsg);
    } finally {
      setIsLoading(false);
    }
  };

  // Filter users based on search
  const filteredUsers = allUsers.filter(user => {
    const searchLower = searchQuery.toLowerCase();
    return (
      user.name.toLowerCase().includes(searchLower) ||
      user.email.toLowerCase().includes(searchLower) ||
      user.username?.toLowerCase().includes(searchLower)
    );
  });

  const handleSendRequest = async (userId: string) => {
    setSendingTo(userId);

    try {
      logger.debug('Add Contact Modal: Sending friend request to:', userId);

      await sendRequest({ receiverId: userId });

      // Remove user from list after sending request
      setAllUsers(prev => prev.filter(u => u.id !== userId));

      logger.success('Add Contact Modal: Friend request sent successfully');
    } catch (error: any) {
      logger.error('Add Contact Modal: Failed to send friend request:', error);

      const errorMsg = error.response?.data?.message || 'Failed to send request';
      toastHelper.error(errorMsg);
    } finally {
      setSendingTo(null);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-md max-h-[80vh] flex flex-col">
        <DialogHeader>
          <DialogTitle>Add Contact</DialogTitle>
          <DialogDescription>
            Find and add people to your contacts
          </DialogDescription>
        </DialogHeader>

        {/* Search Bar */}
        <div className="flex gap-2">
          <div className="relative flex-1">
            <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
            <Input
              type="text"
              placeholder="Search by name, email, or username..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10"
              disabled={isLoading}
            />
          </div>
          <Button
            variant="outline"
            size="icon"
            onClick={fetchAllUsers}
            disabled={isLoading}
            title="Refresh"
          >
            <Loader2 className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} />
          </Button>
        </div>

        {/* Error Message */}
        {error && (
          <div className="rounded-lg border border-destructive/50 bg-destructive/10 p-3">
            <p className="text-sm text-destructive">{error}</p>
          </div>
        )}

        {/* Users List */}
        <div className="flex-1 overflow-y-auto -mx-6 px-6">
          {isLoading ? (
            <div className="flex items-center justify-center py-8">
              <LoadingSpinner text="Loading users..." />
            </div>
          ) : filteredUsers.length === 0 ? (
            <EmptyState
              icon={Users}
              title={
                error
                  ? 'Failed to load users'
                  : searchQuery
                    ? 'No users found'
                    : 'No available users'
              }
              description={
                error
                  ? 'Please check your backend connection'
                  : searchQuery
                    ? 'Try searching with a different name'
                    : 'All available users have been added'
              }
              action={
                error && (
                  <Button onClick={fetchAllUsers}>
                    Try Again
                  </Button>
                )
              }
            />
          ) : (
            <div className="space-y-2">
              {filteredUsers.map((user) => (
                <div
                  key={user.id}
                  className="flex items-center gap-3 p-3 rounded-lg border bg-card"
                >
                  <UserAvatar
                    src={user.avatar}
                    name={user.name}
                    size="lg"
                    online={user.isOnline}
                  />

                  <div className="flex-1 overflow-hidden">
                    <h4 className="truncate font-semibold text-foreground">
                      {user.name}
                    </h4>

                    {user.username && (
                      <p className="truncate text-sm text-muted-foreground">
                        @{user.username}
                      </p>
                    )}

                    <p className="truncate text-xs text-muted-foreground">
                      {user.email}
                    </p>

                    {user.about && (
                      <p className="truncate text-xs text-muted-foreground mt-1">
                        {user.about}
                      </p>
                    )}
                  </div>

                  <Button
                    size="sm"
                    onClick={() => handleSendRequest(user.id)}
                    disabled={sendingTo === user.id}
                  >
                    {sendingTo === user.id ? (
                      <Loader2 className="h-4 w-4 animate-spin" />
                    ) : (
                      <>
                        <UserPlus className="h-4 w-4 mr-1" />
                        Add
                      </>
                    )}
                  </Button>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="border-t pt-4">
          <p className="text-xs text-muted-foreground text-center">
            {filteredUsers.length} user{filteredUsers.length !== 1 ? 's' : ''} available
          </p>
        </div>
      </DialogContent>
    </Dialog>
  );
};

================================================
FILE: src/features/contacts/components/contact-item.tsx
================================================

// ================================================
// FILE: src/features/contacts/components/contact-item.tsx
// ContactItem Component - Single contact item
// ================================================

import { MoreVertical } from 'lucide-react';
import { UserAvatar } from '@/shared/components/common/user-avatar';
import { Button } from '@/shared/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/shared/components/ui/dropdown-menu';
import type { ContactWithDetails } from '../types/contact.types';

interface ContactItemProps {
  contact: ContactWithDetails;
  onClick?: () => void;
  onBlock?: () => void;
  onRemove?: () => void;
  onEditNickname?: () => void;
}

export const ContactItem = ({
  contact,
  onClick,
  onBlock,
  onRemove,
  onEditNickname,
}: ContactItemProps) => {
  return (
    <div className="flex items-center gap-3 p-4 transition-colors hover:bg-muted/50">
      <div className="flex-1 flex items-center gap-3 cursor-pointer" onClick={onClick}>
        <UserAvatar
          src={contact.contact.avatar}
          name={contact.contact.name}
          size="lg"
          online={contact.contact.isOnline}
        />

        <div className="flex-1 overflow-hidden">
          <h4 className="truncate font-semibold text-foreground">
            {contact.nickname || contact.contact.name}
          </h4>

          {contact.nickname && (
            <p className="truncate text-sm text-muted-foreground">
              {contact.contact.name}
            </p>
          )}

          {contact.contact.about && (
            <p className="truncate text-xs text-muted-foreground">
              {contact.contact.about}
            </p>
          )}
        </div>
      </div>

      {/* Actions Menu */}
      {(onBlock || onRemove || onEditNickname) && (
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="ghost" size="icon">
              <MoreVertical className="h-5 w-5" />
            </Button>
          </DropdownMenuTrigger>

          <DropdownMenuContent align="end">
            {onEditNickname && (
              <DropdownMenuItem onClick={onEditNickname}>
                Edit Nickname
              </DropdownMenuItem>
            )}

            {onBlock && (
              <DropdownMenuItem onClick={onBlock}>
                Block Contact
              </DropdownMenuItem>
            )}

            {onRemove && (
              <DropdownMenuItem
                onClick={onRemove}
                className="text-destructive"
              >
                Remove Contact
              </DropdownMenuItem>
            )}
          </DropdownMenuContent>
        </DropdownMenu>
      )}
    </div>
  );
};

================================================
FILE: src/features/contacts/components/contact-list.tsx
================================================

// ================================================
// FILE: src/features/contacts/components/contact-list.tsx
// ContactList Component - Display list of contacts
// ================================================

import { Users } from 'lucide-react';
import { ContactItem } from './contact-item';
import { EmptyState } from '@/shared/components/common/empty-state';
import { LoadingSpinner } from '@/shared/components/common/loading-spinner';
import { Button } from '@/shared/components/ui/button';
import type { ContactWithDetails } from '../types/contact.types';

interface ContactListProps {
  contacts: ContactWithDetails[];
  isLoading?: boolean;
  onContactClick?: (contactId: string) => void;
  onAddContact?: () => void;
}

export const ContactList = ({
  contacts,
  isLoading,
  onContactClick,
  onAddContact,
}: ContactListProps) => {
  if (isLoading) {
    return (
      <div className="flex h-full items-center justify-center">
        <LoadingSpinner text="Loading contacts..." />
      </div>
    );
  }

  if (contacts.length === 0) {
    return (
      <EmptyState
        icon={Users}
        title="No contacts yet"
        description="Add friends to start chatting"
        action={
          onAddContact && (
            <Button onClick={onAddContact}>
              Add Contact
            </Button>
          )
        }
      />
    );
  }

  return (
    <div className="divide-y">
      {contacts.map((contact) => (
        <ContactItem
          key={contact.id}
          contact={contact}
          onClick={() => onContactClick?.(contact.contactId)}
        />
      ))}
    </div>
  );
};

================================================
FILE: src/features/contacts/components/friend-request-item.tsx
================================================

// ================================================
// FILE: src/features/contacts/components/friend-request-item.tsx
// FriendRequestItem Component - Friend request card
// ================================================

import { Check, X } from 'lucide-react';
import { UserAvatar } from '@/shared/components/common/user-avatar';
import { Button } from '@/shared/components/ui/button';
import { dateFormatter } from '@/shared/utils/date-formatter';
import type { FriendRequestWithDetails } from '../types/contact.types';

interface FriendRequestItemProps {
  request: FriendRequestWithDetails;
  type: 'received' | 'sent';
  onAccept?: () => void;
  onReject?: () => void;
  onCancel?: () => void;
}

export const FriendRequestItem = ({
  request,
  type,
  onAccept,
  onReject,
  onCancel,
}: FriendRequestItemProps) => {
  const user = type === 'received' ? request.sender : request.receiver;

  return (
    <div className="flex items-center gap-3 p-4 rounded-lg border bg-card">
      <UserAvatar
        src={user.avatar}
        name={user.name}
        size="lg"
      />

      <div className="flex-1 overflow-hidden">
        <h4 className="truncate font-semibold text-foreground">
          {user.name}
        </h4>

        <p className="truncate text-sm text-muted-foreground">
          {user.username ? `@${user.username}` : user.email}
        </p>

        <p className="text-xs text-muted-foreground mt-1">
          {dateFormatter.relativeTime(request.createdAt)}
        </p>
      </div>

      {/* Actions */}
      <div className="flex gap-2">
        {type === 'received' ? (
          <>
            <Button
              size="icon"
              variant="ghost"
              onClick={onReject}
              className="text-destructive hover:text-destructive"
            >
              <X className="h-5 w-5" />
            </Button>

            <Button
              size="icon"
              onClick={onAccept}
              className="bg-green-500 hover:bg-green-600"
            >
              <Check className="h-5 w-5" />
            </Button>
          </>
        ) : (
          <Button
            size="sm"
            variant="outline"
            onClick={onCancel}
          >
            Cancel
          </Button>
        )}
      </div>
    </div>
  );
};

================================================
FILE: src/features/contacts/hooks/use-contacts.ts
================================================

// ================================================
// FILE: src/features/contacts/hooks/use-contacts.ts
// useContacts Hook - Handle contacts & friend requests (CLEANED)
// ================================================

import { useEffect } from 'react';
import { useContactStore } from '../store/contact.store';
import { socketClient } from '@/lib/socket-client';
import { SOCKET_EVENTS } from '@/shared/constants/socket-events';
import { toastHelper } from '@/shared/utils/toast-helper';
import { logger } from '@/shared/utils/logger';
import type {
  SendRequestInput,
  BlockContactInput,
  UpdateNicknameInput,
  FriendRequestWithDetails
} from '../types/contact.types';

// ‚úÖ GLOBAL FLAGS (outside React component lifecycle)
let GLOBAL_CONTACTS_FETCHED = false;

export const useContacts = () => {
  const {
    contacts,
    blockedContacts,
    pendingRequests,
    sentRequests,
    isLoading,
    error,
    fetchContacts,
    fetchBlockedContacts,
    fetchPendingRequests,
    fetchSentRequests,
    sendRequest,
    acceptRequest,
    rejectRequest,
    cancelRequest,
    blockContact,
    unblockContact,
    removeContact,
    updateNickname,
    addPendingRequest,
    removePendingRequest,
    removeSentRequest,
    addSentRequest,
    clearError,
  } = useContactStore();

  // ‚úÖ Fetch data on mount (ONLY ONCE using global flag)
  useEffect(() => {
    if (!GLOBAL_CONTACTS_FETCHED) {
      logger.debug('useContacts: Fetching initial data...');

      fetchContacts();
      fetchPendingRequests();
      fetchSentRequests();

      GLOBAL_CONTACTS_FETCHED = true; // ‚úÖ Set global flag

      logger.success('useContacts: Initial data fetch triggered');
    }
  }, [fetchContacts, fetchPendingRequests, fetchSentRequests]);

  // Listen to friend request received
  useEffect(() => {
    const handleRequestReceived = (data: { request: FriendRequestWithDetails }) => {
      logger.info('useContacts: Friend request received from:', data.request.sender.name);

      addPendingRequest(data.request);

      // Show notification toast
      toastHelper.info(`${data.request.sender.name} sent you a friend request`);

      // Optional: Browser notification
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification('New Friend Request', {
          body: `${data.request.sender.name} sent you a friend request`,
          icon: data.request.sender.avatar || undefined,
        });
      }
    };

    socketClient.on(SOCKET_EVENTS.FRIEND_REQUEST_RECEIVED, handleRequestReceived);

    return () => {
      socketClient.off(SOCKET_EVENTS.FRIEND_REQUEST_RECEIVED, handleRequestReceived);
    };
  }, [addPendingRequest]);

  // Listen to friend request accepted
  useEffect(() => {
    const handleRequestAccepted = (data: { request: FriendRequestWithDetails }) => {
      logger.success('useContacts: Friend request accepted by:', data.request.receiver.name);

      removeSentRequest(data.request.id);
      fetchContacts(); // Refresh contacts list

      // Show success notification
      toastHelper.success(`${data.request.receiver.name} accepted your friend request!`);

      // Optional: Browser notification
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification('Friend Request Accepted', {
          body: `${data.request.receiver.name} accepted your friend request`,
          icon: data.request.receiver.avatar || undefined,
        });
      }
    };

    socketClient.on(SOCKET_EVENTS.FRIEND_REQUEST_ACCEPTED, handleRequestAccepted);

    return () => {
      socketClient.off(SOCKET_EVENTS.FRIEND_REQUEST_ACCEPTED, handleRequestAccepted);
    };
  }, [removeSentRequest, fetchContacts]);

  // Listen to friend request rejected
  useEffect(() => {
    const handleRequestRejected = (data: { request: FriendRequestWithDetails }) => {
      logger.info('useContacts: Friend request rejected by:', data.request.receiver.name);

      removeSentRequest(data.request.id);
    };

    socketClient.on(SOCKET_EVENTS.FRIEND_REQUEST_REJECTED, handleRequestRejected);

    return () => {
      socketClient.off(SOCKET_EVENTS.FRIEND_REQUEST_REJECTED, handleRequestRejected);
    };
  }, [removeSentRequest]);

  // Send friend request
  const handleSendRequest = async (data: SendRequestInput) => {
    try {
      logger.debug('useContacts: Sending friend request to:', data.receiverId);

      const request = await sendRequest(data);

      // Refresh sent requests to show the new one
      await fetchSentRequests();

      logger.success('useContacts: Friend request sent successfully');

      return request;
    } catch (error: any) {
      logger.error('useContacts: Failed to send request:', error);
      throw error;
    }
  };

  // Accept request
  const handleAcceptRequest = async (requestId: string) => {
    try {
      logger.debug('useContacts: Accepting friend request:', requestId);

      await acceptRequest(requestId);

      // Refresh contacts and pending requests
      await fetchContacts();
      await fetchPendingRequests();

      logger.success('useContacts: Friend request accepted successfully');
    } catch (error) {
      logger.error('useContacts: Failed to accept request:', error);
      throw error;
    }
  };

  // Reject request
  const handleRejectRequest = async (requestId: string) => {
    try {
      logger.debug('useContacts: Rejecting friend request:', requestId);

      await rejectRequest(requestId);

      logger.success('useContacts: Friend request rejected successfully');
    } catch (error) {
      logger.error('useContacts: Failed to reject request:', error);
      throw error;
    }
  };

  // Cancel request
  const handleCancelRequest = async (requestId: string) => {
    try {
      logger.debug('useContacts: Cancelling friend request:', requestId);

      await cancelRequest(requestId);

      logger.success('useContacts: Friend request cancelled successfully');
    } catch (error) {
      logger.error('useContacts: Failed to cancel request:', error);
      throw error;
    }
  };

  // Block contact
  const handleBlockContact = async (data: BlockContactInput) => {
    try {
      logger.debug('useContacts: Blocking contact:', data.contactId);

      await blockContact(data);

      logger.success('useContacts: Contact blocked successfully');
    } catch (error) {
      logger.error('useContacts: Failed to block contact:', error);
      throw error;
    }
  };

  // Unblock contact
  const handleUnblockContact = async (data: BlockContactInput) => {
    try {
      logger.debug('useContacts: Unblocking contact:', data.contactId);

      await unblockContact(data);

      logger.success('useContacts: Contact unblocked successfully');
    } catch (error) {
      logger.error('useContacts: Failed to unblock contact:', error);
      throw error;
    }
  };

  // Remove contact
  const handleRemoveContact = async (contactId: string) => {
    try {
      logger.debug('useContacts: Removing contact:', contactId);

      await removeContact(contactId);

      logger.success('useContacts: Contact removed successfully');
    } catch (error) {
      logger.error('useContacts: Failed to remove contact:', error);
      throw error;
    }
  };

  // Update nickname
  const handleUpdateNickname = async (data: UpdateNicknameInput) => {
    try {
      logger.debug('useContacts: Updating nickname:', data);

      await updateNickname(data);

      logger.success('useContacts: Nickname updated successfully');
    } catch (error) {
      logger.error('useContacts: Failed to update nickname:', error);
      throw error;
    }
  };

  return {
    contacts,
    blockedContacts,
    pendingRequests,
    sentRequests,
    isLoading,
    error,
    sendRequest: handleSendRequest,
    acceptRequest: handleAcceptRequest,
    rejectRequest: handleRejectRequest,
    cancelRequest: handleCancelRequest,
    blockContact: handleBlockContact,
    unblockContact: handleUnblockContact,
    removeContact: handleRemoveContact,
    updateNickname: handleUpdateNickname,
    fetchBlockedContacts,
    clearError,
  };
};

// ‚úÖ EXPORT: Reset function for logout
export const resetContactsFetch = () => {
  GLOBAL_CONTACTS_FETCHED = false;
  logger.debug('useContacts: Reset fetch flag');
};

================================================
FILE: src/features/contacts/pages/contacts-page.tsx
================================================

// ================================================
// FILE: src/features/contacts/pages/contacts-page.tsx
// ContactsPage - Contacts and friend requests page (CLEANED)
// ================================================

import { useState } from 'react';
import { UserPlus } from 'lucide-react';
import { AppLayout } from '@/shared/components/layouts/app-layout';
import { PageLayout } from '@/shared/components/common/page-layout';
import { Button } from '@/shared/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/shared/components/ui/tabs';
import { ContactList } from '../components/contact-list';
import { FriendRequestItem } from '../components/friend-request-item';
import { AddContactModal } from '../components/add-contact-modal';
import { SearchBar } from '@/shared/components/common/search-bar';
import { useContacts } from '../hooks/use-contacts';
import { logger } from '@/shared/utils/logger';

export const ContactsPage = () => {
  const {
    contacts,
    pendingRequests,
    sentRequests,
    isLoading,
    acceptRequest,
    rejectRequest,
    cancelRequest,
  } = useContacts();

  const [searchQuery, setSearchQuery] = useState('');
  const [showAddModal, setShowAddModal] = useState(false);
  const [activeTab, setActiveTab] = useState('contacts');

  // Filter contacts based on search
  const filteredContacts = contacts.filter((contact) =>
    contact.contact.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    contact.contact.username?.toLowerCase().includes(searchQuery.toLowerCase()) ||
    contact.contact.email.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const handleAcceptRequest = async (requestId: string) => {
    try {
      logger.debug('Contacts Page: Accepting request:', requestId);

      await acceptRequest(requestId);

      // Switch to contacts tab to see the new contact
      setActiveTab('contacts');

      logger.success('Contacts Page: Request accepted, switched to contacts tab');
    } catch (error) {
      logger.error('Contacts Page: Failed to accept request:', error);
    }
  };

  const handleRejectRequest = async (requestId: string) => {
    try {
      logger.debug('Contacts Page: Rejecting request:', requestId);

      await rejectRequest(requestId);

      logger.success('Contacts Page: Request rejected');
    } catch (error) {
      logger.error('Contacts Page: Failed to reject request:', error);
    }
  };

  const handleCancelRequest = async (requestId: string) => {
    try {
      logger.debug('Contacts Page: Cancelling request:', requestId);

      await cancelRequest(requestId);

      logger.success('Contacts Page: Request cancelled');
    } catch (error) {
      logger.error('Contacts Page: Failed to cancel request:', error);
    }
  };

  const header = (
    <div className="flex items-center justify-between">
      <div>
        <h1 className="text-2xl font-bold">Contacts</h1>
        <p className="text-sm text-muted-foreground mt-1">
          {contacts.length} contact{contacts.length !== 1 ? 's' : ''}
          {pendingRequests.length > 0 && ` ‚Ä¢ ${pendingRequests.length} pending`}
        </p>
      </div>
      <Button onClick={() => setShowAddModal(true)}>
        <UserPlus className="mr-2 h-4 w-4" />
        Add Contact
      </Button>
    </div>
  );

  return (
    <AppLayout>
      <PageLayout header={header}>
        <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-4">
          <TabsList className="grid w-full grid-cols-3">
            <TabsTrigger value="contacts">
              Contacts
              {contacts.length > 0 && (
                <span className="ml-2 rounded-full bg-primary/10 px-2 py-0.5 text-xs">
                  {contacts.length}
                </span>
              )}
            </TabsTrigger>
            <TabsTrigger value="pending">
              Requests
              {pendingRequests.length > 0 && (
                <span className="ml-2 rounded-full bg-destructive/10 px-2 py-0.5 text-xs text-destructive">
                  {pendingRequests.length}
                </span>
              )}
            </TabsTrigger>
            <TabsTrigger value="sent">
              Sent
              {sentRequests.length > 0 && (
                <span className="ml-2 rounded-full bg-muted px-2 py-0.5 text-xs">
                  {sentRequests.length}
                </span>
              )}
            </TabsTrigger>
          </TabsList>

          {/* Contacts Tab */}
          <TabsContent value="contacts" className="space-y-4">
            <SearchBar
              placeholder="Search contacts..."
              onSearch={setSearchQuery}
            />
            <ContactList
              contacts={filteredContacts}
              isLoading={isLoading}
              onAddContact={() => setShowAddModal(true)}
            />
          </TabsContent>

          {/* Pending Requests Tab */}
          <TabsContent value="pending" className="space-y-4">
            {isLoading ? (
              <div className="text-center py-8 text-muted-foreground">
                Loading requests...
              </div>
            ) : pendingRequests.length === 0 ? (
              <div className="text-center py-12">
                <div className="mb-4 inline-flex rounded-full bg-muted p-4">
                  <UserPlus className="h-8 w-8 text-muted-foreground" />
                </div>
                <h3 className="text-lg font-semibold mb-2">No pending requests</h3>
                <p className="text-sm text-muted-foreground mb-4">
                  Friend requests will appear here
                </p>
              </div>
            ) : (
              <div className="space-y-3">
                {pendingRequests.map((request) => (
                  <FriendRequestItem
                    key={request.id}
                    request={request}
                    type="received"
                    onAccept={() => handleAcceptRequest(request.id)}
                    onReject={() => handleRejectRequest(request.id)}
                  />
                ))}
              </div>
            )}
          </TabsContent>

          {/* Sent Requests Tab */}
          <TabsContent value="sent" className="space-y-4">
            {isLoading ? (
              <div className="text-center py-8 text-muted-foreground">
                Loading requests...
              </div>
            ) : sentRequests.length === 0 ? (
              <div className="text-center py-12">
                <div className="mb-4 inline-flex rounded-full bg-muted p-4">
                  <UserPlus className="h-8 w-8 text-muted-foreground" />
                </div>
                <h3 className="text-lg font-semibold mb-2">No sent requests</h3>
                <p className="text-sm text-muted-foreground mb-4">
                  Requests you send will appear here
                </p>
                <Button onClick={() => setShowAddModal(true)}>
                  <UserPlus className="mr-2 h-4 w-4" />
                  Find People
                </Button>
              </div>
            ) : (
              <div className="space-y-3">
                {sentRequests.map((request) => (
                  <FriendRequestItem
                    key={request.id}
                    request={request}
                    type="sent"
                    onCancel={() => handleCancelRequest(request.id)}
                  />
                ))}
              </div>
            )}
          </TabsContent>
        </Tabs>
      </PageLayout>

      {/* Add Contact Modal */}
      <AddContactModal
        open={showAddModal}
        onOpenChange={setShowAddModal}
      />
    </AppLayout>
  );
};

================================================
FILE: src/features/contacts/services/contact.service.ts
================================================

// ================================================
// FILE: src/features/contacts/services/contact.service.ts
// Contact Service - Handle all contact API calls (CLEANED)
// ================================================

import { axiosClient } from '@/lib/axios-client';
import { API_ENDPOINTS } from '@/shared/constants/api-endpoints';
import { logger } from '@/shared/utils/logger';
import type { ApiResponse } from '@/shared/types/api-types';
import type {
  Contact,
  ContactWithDetails,
  BlockContactInput,
  UpdateNicknameInput
} from '../types/contact.types';

export const contactService = {
  // Get all contacts
  getContacts: async (): Promise<ContactWithDetails[]> => {
    logger.debug('Contact Service: Getting contacts...');

    const response = await axiosClient.get<ApiResponse<ContactWithDetails[]>>(
      API_ENDPOINTS.CONTACT.LIST
    );

    logger.success('Contact Service: Contacts retrieved:', response.data.data?.length || 0);

    return response.data.data || [];
  },

  // Get blocked contacts
  getBlockedContacts: async (): Promise<ContactWithDetails[]> => {
    logger.debug('Contact Service: Getting blocked contacts...');

    const response = await axiosClient.get<ApiResponse<ContactWithDetails[]>>(
      API_ENDPOINTS.CONTACT.BLOCKED
    );

    logger.success('Contact Service: Blocked contacts retrieved:', response.data.data?.length || 0);

    return response.data.data || [];
  },

  // Block contact
  blockContact: async (data: BlockContactInput): Promise<void> => {
    logger.debug('Contact Service: Blocking contact:', data.contactId);

    await axiosClient.post(API_ENDPOINTS.CONTACT.BLOCK, data);

    logger.success('Contact Service: Contact blocked');
  },

  // Unblock contact
  unblockContact: async (data: BlockContactInput): Promise<void> => {
    logger.debug('Contact Service: Unblocking contact:', data.contactId);

    await axiosClient.post(API_ENDPOINTS.CONTACT.UNBLOCK, data);

    logger.success('Contact Service: Contact unblocked');
  },

  // Remove contact
  removeContact: async (contactId: string): Promise<void> => {
    logger.debug('Contact Service: Removing contact:', contactId);

    await axiosClient.delete(API_ENDPOINTS.CONTACT.REMOVE(contactId));

    logger.success('Contact Service: Contact removed');
  },

  // Update nickname
  updateNickname: async (data: UpdateNicknameInput): Promise<ContactWithDetails> => {
    logger.debug('Contact Service: Updating nickname:', data);

    const response = await axiosClient.patch<ApiResponse<ContactWithDetails>>(
      API_ENDPOINTS.CONTACT.NICKNAME,
      data
    );

    logger.success('Contact Service: Nickname updated');

    return response.data.data!;
  },
};

================================================
FILE: src/features/contacts/services/friend-request.service.ts
================================================

// ================================================
// FILE: src/features/contacts/services/friend-request.service.ts
// Friend Request Service - Handle all friend request API calls (CLEANED)
// ================================================

import { axiosClient } from '@/lib/axios-client';
import { API_ENDPOINTS } from '@/shared/constants/api-endpoints';
import { logger } from '@/shared/utils/logger';
import type { ApiResponse } from '@/shared/types/api-types';
import type {
  FriendRequest,
  FriendRequestWithDetails,
  SendRequestInput,
  FriendStatus
} from '../types/contact.types';

export const friendRequestService = {
  // Send friend request
  sendRequest: async (data: SendRequestInput): Promise<FriendRequestWithDetails> => {
    logger.debug('Friend Request Service: Sending request to:', data.receiverId);

    const response = await axiosClient.post<ApiResponse<FriendRequestWithDetails>>(
      API_ENDPOINTS.FRIEND_REQUEST.SEND,
      data
    );

    logger.success('Friend Request Service: Request sent successfully');

    return response.data.data!;
  },

  // Get pending requests (received)
  getPendingRequests: async (): Promise<FriendRequestWithDetails[]> => {
    logger.debug('Friend Request Service: Getting pending requests...');

    const response = await axiosClient.get<ApiResponse<FriendRequestWithDetails[]>>(
      API_ENDPOINTS.FRIEND_REQUEST.PENDING
    );

    logger.success('Friend Request Service: Pending requests retrieved:', response.data.data?.length || 0);

    return response.data.data || [];
  },

  // Get sent requests
  getSentRequests: async (): Promise<FriendRequestWithDetails[]> => {
    logger.debug('Friend Request Service: Getting sent requests...');

    const response = await axiosClient.get<ApiResponse<FriendRequestWithDetails[]>>(
      API_ENDPOINTS.FRIEND_REQUEST.SENT
    );

    logger.success('Friend Request Service: Sent requests retrieved:', response.data.data?.length || 0);

    return response.data.data || [];
  },

  // Accept friend request
  acceptRequest: async (requestId: string): Promise<FriendRequestWithDetails> => {
    logger.debug('Friend Request Service: Accepting request:', requestId);

    const response = await axiosClient.post<ApiResponse<FriendRequestWithDetails>>(
      API_ENDPOINTS.FRIEND_REQUEST.ACCEPT(requestId)
    );

    logger.success('Friend Request Service: Request accepted');

    return response.data.data!;
  },

  // Reject friend request
  rejectRequest: async (requestId: string): Promise<FriendRequestWithDetails> => {
    logger.debug('Friend Request Service: Rejecting request:', requestId);

    const response = await axiosClient.post<ApiResponse<FriendRequestWithDetails>>(
      API_ENDPOINTS.FRIEND_REQUEST.REJECT(requestId)
    );

    logger.success('Friend Request Service: Request rejected');

    return response.data.data!;
  },

  // Cancel friend request
  cancelRequest: async (requestId: string): Promise<void> => {
    logger.debug('Friend Request Service: Cancelling request:', requestId);

    await axiosClient.delete(API_ENDPOINTS.FRIEND_REQUEST.CANCEL(requestId));

    logger.success('Friend Request Service: Request cancelled');
  },

  // Check friend status with user
  checkFriendStatus: async (userId: string): Promise<FriendStatus> => {
    logger.debug('Friend Request Service: Checking friend status with:', userId);

    const response = await axiosClient.get<ApiResponse<FriendStatus>>(
      API_ENDPOINTS.FRIEND_REQUEST.STATUS(userId)
    );

    logger.success('Friend Request Service: Friend status retrieved');

    return response.data.data!;
  },
};

================================================
FILE: src/features/contacts/store/contact.store.ts
================================================

// ================================================
// FILE: src/features/contacts/store/contact.store.ts
// Contact Store - Global contacts & friend requests state (CLEANED)
// ================================================

import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { contactService } from '../services/contact.service';
import { friendRequestService } from '../services/friend-request.service';
import { toastHelper } from '@/shared/utils/toast-helper';
import { logger } from '@/shared/utils/logger';
import type {
  ContactWithDetails,
  FriendRequestWithDetails,
  SendRequestInput,
  BlockContactInput,
  UpdateNicknameInput
} from '../types/contact.types';

interface ContactState {
  // State
  contacts: ContactWithDetails[];
  blockedContacts: ContactWithDetails[];
  pendingRequests: FriendRequestWithDetails[];
  sentRequests: FriendRequestWithDetails[];
  isLoading: boolean;
  error: string | null;

  // Actions - Contacts
  fetchContacts: () => Promise<void>;
  fetchBlockedContacts: () => Promise<void>;
  blockContact: (data: BlockContactInput) => Promise<void>;
  unblockContact: (data: BlockContactInput) => Promise<void>;
  removeContact: (contactId: string) => Promise<void>;
  updateNickname: (data: UpdateNicknameInput) => Promise<void>;

  // Actions - Friend Requests
  fetchPendingRequests: () => Promise<void>;
  fetchSentRequests: () => Promise<void>;
  sendRequest: (data: SendRequestInput) => Promise<FriendRequestWithDetails>;
  acceptRequest: (requestId: string) => Promise<void>;
  rejectRequest: (requestId: string) => Promise<void>;
  cancelRequest: (requestId: string) => Promise<void>;
  addPendingRequest: (request: FriendRequestWithDetails) => void;
  removePendingRequest: (requestId: string) => void;
  removeSentRequest: (requestId: string) => void;
  addSentRequest: (request: FriendRequestWithDetails) => void;

  // Utils
  clearError: () => void;
  reset: () => void;
}

export const useContactStore = create<ContactState>()(
  devtools(
    (set, get) => ({
      // Initial state
      contacts: [],
      blockedContacts: [],
      pendingRequests: [],
      sentRequests: [],
      isLoading: false,
      error: null,

      // Fetch contacts
      fetchContacts: async () => {
        set({ isLoading: true, error: null });
        try {
          logger.debug('Contact Store: Fetching contacts...');
          const contacts = await contactService.getContacts();

          set({
            contacts,
            isLoading: false
          });

          logger.success('Contact Store: Contacts fetched:', contacts.length);
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to fetch contacts';

          logger.error('Contact Store: Fetch contacts failed:', error);

          set({
            error: errorMsg,
            isLoading: false
          });

          // Silent error - no toast for background fetch
        }
      },

      // Fetch blocked contacts
      fetchBlockedContacts: async () => {
        set({ isLoading: true, error: null });
        try {
          logger.debug('Contact Store: Fetching blocked contacts...');
          const blockedContacts = await contactService.getBlockedContacts();

          set({
            blockedContacts,
            isLoading: false
          });

          logger.success('Contact Store: Blocked contacts fetched:', blockedContacts.length);
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to fetch blocked contacts';

          logger.error('Contact Store: Fetch blocked contacts failed:', error);

          set({
            error: errorMsg,
            isLoading: false
          });

          // Silent error - no toast for background fetch
        }
      },

      // Block contact
      blockContact: async (data) => {
        try {
          logger.debug('Contact Store: Blocking contact:', data.contactId);
          await contactService.blockContact(data);

          toastHelper.success('Contact blocked successfully');

          set((state) => ({
            contacts: state.contacts.filter((c) => c.contactId !== data.contactId),
          }));

          await get().fetchBlockedContacts();

          logger.success('Contact Store: Contact blocked');
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to block contact';

          logger.error('Contact Store: Block contact failed:', error);
          toastHelper.error(errorMsg);

          set({ error: errorMsg });
          throw error;
        }
      },

      // Unblock contact
      unblockContact: async (data) => {
        try {
          logger.debug('Contact Store: Unblocking contact:', data.contactId);
          await contactService.unblockContact(data);

          toastHelper.success('Contact unblocked successfully');

          await get().fetchBlockedContacts();

          logger.success('Contact Store: Contact unblocked');
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to unblock contact';

          logger.error('Contact Store: Unblock contact failed:', error);
          toastHelper.error(errorMsg);

          set({ error: errorMsg });
          throw error;
        }
      },

      // Remove contact
      removeContact: async (contactId) => {
        try {
          logger.debug('Contact Store: Removing contact:', contactId);
          await contactService.removeContact(contactId);

          toastHelper.success('Contact removed successfully');

          set((state) => ({
            contacts: state.contacts.filter((c) => c.contactId !== contactId),
          }));

          logger.success('Contact Store: Contact removed');
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to remove contact';

          logger.error('Contact Store: Remove contact failed:', error);
          toastHelper.error(errorMsg);

          set({ error: errorMsg });
          throw error;
        }
      },

      // Update nickname
      updateNickname: async (data) => {
        try {
          logger.debug('Contact Store: Updating nickname:', data);
          const updated = await contactService.updateNickname(data);

          toastHelper.success('Nickname updated successfully');

          set((state) => ({
            contacts: state.contacts.map((c) =>
              c.contactId === data.contactId ? updated : c
            ),
          }));

          logger.success('Contact Store: Nickname updated');
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to update nickname';

          logger.error('Contact Store: Update nickname failed:', error);
          toastHelper.error(errorMsg);

          set({ error: errorMsg });
          throw error;
        }
      },

      // Fetch pending requests
      fetchPendingRequests: async () => {
        set({ isLoading: true, error: null });
        try {
          logger.debug('Contact Store: Fetching pending requests...');
          const requests = await friendRequestService.getPendingRequests();

          set({
            pendingRequests: requests,
            isLoading: false
          });

          logger.success('Contact Store: Pending requests fetched:', requests.length);
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to fetch pending requests';

          logger.error('Contact Store: Fetch pending requests failed:', error);

          set({
            error: errorMsg,
            isLoading: false
          });

          // Silent error - no toast for background fetch
        }
      },

      // Fetch sent requests
      fetchSentRequests: async () => {
        set({ isLoading: true, error: null });
        try {
          logger.debug('Contact Store: Fetching sent requests...');
          const requests = await friendRequestService.getSentRequests();

          set({
            sentRequests: requests,
            isLoading: false
          });

          logger.success('Contact Store: Sent requests fetched:', requests.length);
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to fetch sent requests';

          logger.error('Contact Store: Fetch sent requests failed:', error);

          set({
            error: errorMsg,
            isLoading: false
          });

          // Silent error - no toast for background fetch
        }
      },

      // Send friend request
      sendRequest: async (data) => {
        try {
          logger.debug('Contact Store: Sending friend request:', data);
          const request = await friendRequestService.sendRequest(data);

          toastHelper.success('Friend request sent!');

          // Add to sent requests immediately
          set((state) => ({
            sentRequests: [request, ...state.sentRequests],
          }));

          logger.success('Contact Store: Friend request sent');

          return request;
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to send request';

          logger.error('Contact Store: Send request failed:', error);
          toastHelper.error(errorMsg);

          set({ error: errorMsg });
          throw error;
        }
      },

      // Accept request
      acceptRequest: async (requestId) => {
        try {
          logger.debug('Contact Store: Accepting request:', requestId);
          await friendRequestService.acceptRequest(requestId);

          toastHelper.success('Friend request accepted!');

          // Remove from pending requests
          set((state) => ({
            pendingRequests: state.pendingRequests.filter((r) => r.id !== requestId),
          }));

          // Refresh contacts
          await get().fetchContacts();

          logger.success('Contact Store: Request accepted');
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to accept request';

          logger.error('Contact Store: Accept request failed:', error);
          toastHelper.error(errorMsg);

          set({ error: errorMsg });
          throw error;
        }
      },

      // Reject request
      rejectRequest: async (requestId) => {
        try {
          logger.debug('Contact Store: Rejecting request:', requestId);
          await friendRequestService.rejectRequest(requestId);

          toastHelper.success('Friend request rejected');

          // Remove from pending requests
          set((state) => ({
            pendingRequests: state.pendingRequests.filter((r) => r.id !== requestId),
          }));

          logger.success('Contact Store: Request rejected');
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to reject request';

          logger.error('Contact Store: Reject request failed:', error);
          toastHelper.error(errorMsg);

          set({ error: errorMsg });
          throw error;
        }
      },

      // Cancel request
      cancelRequest: async (requestId) => {
        try {
          logger.debug('Contact Store: Cancelling request:', requestId);
          await friendRequestService.cancelRequest(requestId);

          toastHelper.success('Friend request cancelled');

          // Remove from sent requests
          set((state) => ({
            sentRequests: state.sentRequests.filter((r) => r.id !== requestId),
          }));

          logger.success('Contact Store: Request cancelled');
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to cancel request';

          logger.error('Contact Store: Cancel request failed:', error);
          toastHelper.error(errorMsg);

          set({ error: errorMsg });
          throw error;
        }
      },

      // Add pending request (from socket)
      addPendingRequest: (request) => {
        logger.debug('Contact Store: Adding pending request:', request.id);

        set((state) => ({
          pendingRequests: [request, ...state.pendingRequests],
        }));
      },

      // Remove pending request
      removePendingRequest: (requestId) => {
        logger.debug('Contact Store: Removing pending request:', requestId);

        set((state) => ({
          pendingRequests: state.pendingRequests.filter((r) => r.id !== requestId),
        }));
      },

      // Remove sent request
      removeSentRequest: (requestId) => {
        logger.debug('Contact Store: Removing sent request:', requestId);

        set((state) => ({
          sentRequests: state.sentRequests.filter((r) => r.id !== requestId),
        }));
      },

      // Add sent request
      addSentRequest: (request) => {
        logger.debug('Contact Store: Adding sent request:', request.id);

        set((state) => ({
          sentRequests: [request, ...state.sentRequests],
        }));
      },

      // Clear error
      clearError: () => {
        set({ error: null });
      },

      // Reset store
      reset: () => {
        set({
          contacts: [],
          blockedContacts: [],
          pendingRequests: [],
          sentRequests: [],
          isLoading: false,
          error: null,
        });
      },
    }),
    { name: 'ContactStore' }
  )
);

================================================
FILE: src/features/contacts/types/contact.types.ts
================================================

// ================================================
// FILE: src/features/contacts/types/contact.types.ts
// Contact Types - Contact & Friend Request types
// ================================================

import type { User } from '@/shared/types/user-types';

// Request Status
export enum RequestStatus {
  PENDING = 'PENDING',
  ACCEPTED = 'ACCEPTED',
  REJECTED = 'REJECTED',
}

// Base Contact
export interface Contact {
  id: string;
  userId: string;
  contactId: string;
  nickname: string | null;
  isBlocked: boolean;
  createdAt: string;
  updatedAt: string;
}

// Contact with user details
export interface ContactWithDetails extends Contact {
  contact: User;
}

// Base Friend Request
export interface FriendRequest {
  id: string;
  senderId: string;
  receiverId: string;
  status: RequestStatus;
  createdAt: string;
  updatedAt: string;
}

// Friend Request with user details
export interface FriendRequestWithDetails extends FriendRequest {
  sender: User;
  receiver: User;
}

// Send Friend Request Input
export interface SendRequestInput {
  receiverId: string;
}

// Block Contact Input
export interface BlockContactInput {
  contactId: string;
}

// Update Nickname Input
export interface UpdateNicknameInput {
  contactId: string;
  nickname?: string;
}

// Friend Status
export interface FriendStatus {
  isFriend: boolean;
  requestStatus: RequestStatus | null;
  requestId: string | null;
  canSendRequest: boolean;
}

================================================
FILE: src/features/media/hooks/use-media.ts
================================================

// ================================================
// FILE: src/features/media/hooks/use-media.ts
// useMedia Hook - Handle media upload & management
// ================================================

import { useState } from 'react';
import { mediaService } from '../services/media.service';
import { fileHelper } from '@/shared/utils/file-helper';

export const useMedia = () => {
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);

  // Upload image
  const uploadImage = async (file: File) => {
    // Validate
    const validation = fileHelper.validateImage(file);
    if (!validation.valid) {
      setError(validation.error || 'Invalid image');
      throw new Error(validation.error);
    }

    setIsUploading(true);
    setUploadProgress(0);
    setError(null);

    try {
      // Upload to Cloudinary
      const cloudinaryResult = await mediaService.uploadToCloudinary(
        file,
        (progress) => setUploadProgress(progress)
      );

      // Save to database
      const media = await mediaService.uploadMedia({
        filename: file.name,
        mimeType: file.type,
        size: file.size,
        url: cloudinaryResult.url,
        thumbnailUrl: cloudinaryResult.thumbnailUrl,
        width: cloudinaryResult.width,
        height: cloudinaryResult.height,
      });

      setIsUploading(false);
      setUploadProgress(100);
      return media;
    } catch (error: any) {
      setError(error.message || 'Upload failed');
      setIsUploading(false);
      throw error;
    }
  };

  // Upload video
  const uploadVideo = async (file: File) => {
    // Validate
    const validation = fileHelper.validateVideo(file);
    if (!validation.valid) {
      setError(validation.error || 'Invalid video');
      throw new Error(validation.error);
    }

    setIsUploading(true);
    setUploadProgress(0);
    setError(null);

    try {
      // Upload to Cloudinary
      const cloudinaryResult = await mediaService.uploadToCloudinary(
        file,
        (progress) => setUploadProgress(progress)
      );

      // Save to database
      const media = await mediaService.uploadMedia({
        filename: file.name,
        mimeType: file.type,
        size: file.size,
        url: cloudinaryResult.url,
        thumbnailUrl: cloudinaryResult.thumbnailUrl,
        width: cloudinaryResult.width,
        height: cloudinaryResult.height,
        duration: cloudinaryResult.duration,
      });

      setIsUploading(false);
      setUploadProgress(100);
      return media;
    } catch (error: any) {
      setError(error.message || 'Upload failed');
      setIsUploading(false);
      throw error;
    }
  };

  // Upload file (auto-detect type)
  const uploadFile = async (file: File) => {
    if (fileHelper.isImage(file)) {
      return uploadImage(file);
    } else if (fileHelper.isVideo(file)) {
      return uploadVideo(file);
    } else {
      setError('Unsupported file type');
      throw new Error('Unsupported file type');
    }
  };

  // Clear error
  const clearError = () => {
    setError(null);
  };

  return {
    uploadImage,
    uploadVideo,
    uploadFile,
    isUploading,
    uploadProgress,
    error,
    clearError,
  };
};

================================================
FILE: src/features/media/services/media.service.ts
================================================

// ================================================
// FILE: src/features/media/services/media.service.ts
// Media Service - Handle all media API calls
// ================================================

import { axiosClient } from '@/lib/axios-client';
import { API_ENDPOINTS } from '@/shared/constants/api-endpoints';
import type { ApiResponse } from '@/shared/types/api-types';
import type { MediaItem } from '@/shared/types/media-types';
import type { UploadMediaInput } from '../types/media.types';

export const mediaService = {
  // Upload media
  uploadMedia: async (data: UploadMediaInput): Promise<MediaItem> => {
    const response = await axiosClient.post<ApiResponse<MediaItem>>(
      API_ENDPOINTS.MEDIA.UPLOAD,
      data
    );
    return response.data.data!;
  },

  // Get media by ID
  getMediaById: async (mediaId: string): Promise<MediaItem> => {
    const response = await axiosClient.get<ApiResponse<MediaItem>>(
      API_ENDPOINTS.MEDIA.BY_ID(mediaId)
    );
    return response.data.data!;
  },

  // Get all user media
  getUserMedia: async (): Promise<MediaItem[]> => {
    const response = await axiosClient.get<ApiResponse<MediaItem[]>>(
      API_ENDPOINTS.MEDIA.USER_ALL
    );
    return response.data.data || [];
  },

  // Delete media
  deleteMedia: async (mediaId: string): Promise<void> => {
    await axiosClient.delete(API_ENDPOINTS.MEDIA.DELETE(mediaId));
  },

  // Upload to Cloudinary (client-side)
  uploadToCloudinary: async (
    file: File,
    onProgress?: (progress: number) => void
  ): Promise<{
    url: string;
    thumbnailUrl?: string;
    width?: number;
    height?: number;
    duration?: number;
  }> => {
    const formData = new FormData();
    formData.append('file', file);
    formData.append(
      'upload_preset',
      import.meta.env.VITE_CLOUDINARY_UPLOAD_PRESET || 'chat_app'
    );

    const cloudName = import.meta.env.VITE_CLOUDINARY_CLOUD_NAME;
    const resourceType = file.type.startsWith('video/') ? 'video' : 'image';
    const url = `https://api.cloudinary.com/v1_1/${cloudName}/${resourceType}/upload`;

    const response = await fetch(url, {
      method: 'POST',
      body: formData,
    });

    if (!response.ok) {
      throw new Error('Upload failed');
    }

    const data = await response.json();

    return {
      url: data.secure_url,
      thumbnailUrl: data.thumbnail_url,
      width: data.width,
      height: data.height,
      duration: data.duration,
    };
  },
};

================================================
FILE: src/features/media/store/media.store.ts
================================================



================================================
FILE: src/features/media/types/media.types.ts
================================================

// ================================================
// FILE: src/features/media/types/media.types.ts
// Media Types - Media upload & management types
// ================================================

// Upload Media Input
export interface UploadMediaInput {
  filename: string;
  mimeType: string;
  size: number;
  url: string;
  thumbnailUrl?: string;
  width?: number;
  height?: number;
  duration?: number;
}

// Cloudinary Upload Result
export interface CloudinaryUploadResult {
  url: string;
  thumbnailUrl?: string;
  width?: number;
  height?: number;
  duration?: number;
}

// Upload Progress
export interface UploadProgress {
  id: string;
  file: File;
  progress: number;
  status: 'idle' | 'uploading' | 'success' | 'error';
  url?: string;
  error?: string;
}

================================================
FILE: src/features/profile/hooks/use-profile.ts
================================================

// ================================================
// FILE: src/features/profile/hooks/use-profile.ts
// useProfile Hook - Handle profile & settings logic (CLEANED)
// ================================================

import { useEffect } from 'react';
import { useProfileStore } from '../store/profile.store';
import { useAuthStore } from '@/features/auth/store/auth.store';
import { logger } from '@/shared/utils/logger';
import type {
  UpdateProfileInput,
  ChangePasswordInput,
  UpdatePrivacyInput
} from '../types/profile.types';

export const useProfile = () => {
  const { setUser } = useAuthStore();
  const {
    profile,
    settings,
    isLoading,
    error,
    fetchProfile,
    updateProfile,
    changePassword,
    updatePrivacy,
    clearError,
  } = useProfileStore();

  // Fetch profile on mount
  useEffect(() => {
    logger.debug('useProfile: Fetching profile on mount');
    fetchProfile();
  }, [fetchProfile]);

  // Update profile
  const handleUpdateProfile = async (data: UpdateProfileInput) => {
    try {
      logger.debug('useProfile: Updating profile...');
      await updateProfile(data);

      // Sync with auth store
      if (profile) {
        setUser({ ...profile, ...data });
      }

      logger.success('useProfile: Profile updated successfully');
    } catch (error) {
      logger.error('useProfile: Failed to update profile:', error);
      throw error;
    }
  };

  // Change password
  const handleChangePassword = async (data: ChangePasswordInput) => {
    try {
      logger.debug('useProfile: Changing password...');
      await changePassword(data);
      logger.success('useProfile: Password changed successfully');
    } catch (error) {
      logger.error('useProfile: Failed to change password:', error);
      throw error;
    }
  };

  // Update privacy
  const handleUpdatePrivacy = async (data: UpdatePrivacyInput) => {
    try {
      logger.debug('useProfile: Updating privacy settings...');
      await updatePrivacy(data);
      logger.success('useProfile: Privacy settings updated successfully');
    } catch (error) {
      logger.error('useProfile: Failed to update privacy:', error);
      throw error;
    }
  };

  return {
    profile,
    settings,
    isLoading,
    error,
    updateProfile: handleUpdateProfile,
    changePassword: handleChangePassword,
    updatePrivacy: handleUpdatePrivacy,
    clearError,
  };
};

================================================
FILE: src/features/profile/pages/profile-page.tsx
================================================

// ================================================
// FILE: src/features/profile/pages/profile-page.tsx
// ProfilePage - User profile page (CLEANED)
// ================================================

import { useState } from 'react';
import { Camera, Settings } from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import { AppLayout } from '@/shared/components/layouts/app-layout';
import { PageLayout } from '@/shared/components/common/page-layout';
import { UserAvatar } from '@/shared/components/common/user-avatar';
import { Button } from '@/shared/components/ui/button';
import { Input } from '@/shared/components/ui/input';
import { Label } from '@/shared/components/ui/label';
import { Textarea } from '@/shared/components/ui/textarea';
import { useProfile } from '../hooks/use-profile';
import { ROUTE_PATHS } from '@/shared/constants/route-paths';
import { logger } from '@/shared/utils/logger';

export const ProfilePage = () => {
  const navigate = useNavigate();
  const { profile, isLoading, updateProfile } = useProfile();

  const [isEditing, setIsEditing] = useState(false);
  const [formData, setFormData] = useState({
    name: profile?.name || '',
    about: profile?.about || '',
  });

  const handleSave = async () => {
    try {
      logger.debug('Profile Page: Saving profile...');
      await updateProfile(formData);
      setIsEditing(false);
      logger.success('Profile Page: Profile saved successfully');
    } catch (error) {
      logger.error('Profile Page: Failed to save profile:', error);
    }
  };

  const header = (
    <div className="flex items-center justify-between">
      <h1 className="text-2xl font-bold">Profile</h1>
      <Button
        variant="ghost"
        size="icon"
        onClick={() => navigate(ROUTE_PATHS.SETTINGS)}
      >
        <Settings className="h-5 w-5" />
      </Button>
    </div>
  );

  if (!profile) {
    return (
      <AppLayout>
        <PageLayout header={header}>
          <p className="text-center text-muted-foreground">Loading profile...</p>
        </PageLayout>
      </AppLayout>
    );
  }

  return (
    <AppLayout>
      <PageLayout header={header}>
        <div className="mx-auto max-w-2xl space-y-6">
          {/* Avatar Section */}
          <div className="flex flex-col items-center gap-4">
            <div className="relative">
              <UserAvatar
                src={profile.avatar || profile.profilePhoto}
                name={profile.name}
                size="xl"
              />
              <Button
                size="icon"
                className="absolute bottom-0 right-0 rounded-full"
              >
                <Camera className="h-4 w-4" />
              </Button>
            </div>

            <div className="text-center">
              <h2 className="text-2xl font-bold">{profile.name}</h2>
              {profile.username && (
                <p className="text-muted-foreground">@{profile.username}</p>
              )}
            </div>
          </div>

          {/* Profile Info */}
          <div className="rounded-lg border bg-card p-6 space-y-4">
            <div className="flex items-center justify-between">
              <h3 className="text-lg font-semibold">Profile Information</h3>
              {!isEditing ? (
                <Button
                  variant="outline"
                  onClick={() => setIsEditing(true)}
                >
                  Edit
                </Button>
              ) : (
                <div className="flex gap-2">
                  <Button
                    variant="outline"
                    onClick={() => {
                      setIsEditing(false);
                      setFormData({
                        name: profile.name,
                        about: profile.about || '',
                      });
                    }}
                  >
                    Cancel
                  </Button>
                  <Button onClick={handleSave} disabled={isLoading}>
                    Save
                  </Button>
                </div>
              )}
            </div>

            {isEditing ? (
              <div className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="name">Name</Label>
                  <Input
                    id="name"
                    value={formData.name}
                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="about">About</Label>
                  <Textarea
                    id="about"
                    value={formData.about}
                    onChange={(e) => setFormData({ ...formData, about: e.target.value })}
                    placeholder="Write something about yourself..."
                    rows={3}
                  />
                </div>
              </div>
            ) : (
              <div className="space-y-3">
                <div>
                  <Label className="text-muted-foreground">Email</Label>
                  <p className="text-foreground">{profile.email}</p>
                </div>

                {profile.about && (
                  <div>
                    <Label className="text-muted-foreground">About</Label>
                    <p className="text-foreground">{profile.about}</p>
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
      </PageLayout>
    </AppLayout>
  );
};

================================================
FILE: src/features/profile/services/profile.service.ts
================================================

// ================================================
// FILE: src/features/profile/services/profile.service.ts
// Profile Service - Handle all profile API calls (CLEANED)
// ================================================

import { axiosClient } from '@/lib/axios-client';
import { API_ENDPOINTS } from '@/shared/constants/api-endpoints';
import { logger } from '@/shared/utils/logger';
import type { ApiResponse } from '@/shared/types/api-types';
import type { User } from '@/shared/types/user-types';
import type {
  UpdateProfileInput,
  ChangePasswordInput,
  UpdatePrivacyInput,
  UserSettings
} from '../types/profile.types';

export const profileService = {
  // Get profile
  getProfile: async (): Promise<User> => {
    logger.debug('Profile Service: Getting profile...');

    const response = await axiosClient.get<ApiResponse<User>>(
      API_ENDPOINTS.PROFILE.GET
    );

    logger.success('Profile Service: Profile retrieved');

    return response.data.data!;
  },

  // Update profile
  updateProfile: async (data: UpdateProfileInput): Promise<User> => {
    logger.debug('Profile Service: Updating profile...');

    const response = await axiosClient.patch<ApiResponse<User>>(
      API_ENDPOINTS.PROFILE.UPDATE,
      data
    );

    logger.success('Profile Service: Profile updated');

    return response.data.data!;
  },

  // Change password
  changePassword: async (data: ChangePasswordInput): Promise<void> => {
    logger.debug('Profile Service: Changing password...');

    await axiosClient.post(API_ENDPOINTS.PROFILE.CHANGE_PASSWORD, data);

    logger.success('Profile Service: Password changed');
  },

  // Update privacy settings
  updatePrivacy: async (data: UpdatePrivacyInput): Promise<UserSettings> => {
    logger.debug('Profile Service: Updating privacy settings...');

    const response = await axiosClient.patch<ApiResponse<UserSettings>>(
      API_ENDPOINTS.PROFILE.PRIVACY,
      data
    );

    logger.success('Profile Service: Privacy settings updated');

    return response.data.data!;
  },
};

================================================
FILE: src/features/profile/store/profile.store.ts
================================================

// ================================================
// FILE: src/features/profile/store/profile.store.ts
// Profile Store - Global profile & settings state (CLEANED)
// ================================================

import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { profileService } from '../services/profile.service';
import { toastHelper } from '@/shared/utils/toast-helper';
import { logger } from '@/shared/utils/logger';
import type { User } from '@/shared/types/user-types';
import type {
  UpdateProfileInput,
  ChangePasswordInput,
  UpdatePrivacyInput,
  UserSettings
} from '../types/profile.types';

interface ProfileState {
  // State
  profile: User | null;
  settings: UserSettings | null;
  isLoading: boolean;
  error: string | null;

  // Actions
  fetchProfile: () => Promise<void>;
  updateProfile: (data: UpdateProfileInput) => Promise<void>;
  changePassword: (data: ChangePasswordInput) => Promise<void>;
  updatePrivacy: (data: UpdatePrivacyInput) => Promise<void>;
  setProfile: (profile: User) => void;
  setSettings: (settings: UserSettings) => void;

  // Utils
  clearError: () => void;
  reset: () => void;
}

export const useProfileStore = create<ProfileState>()(
  devtools(
    persist(
      (set, get) => ({
        // Initial state
        profile: null,
        settings: null,
        isLoading: false,
        error: null,

        // Fetch profile
        fetchProfile: async () => {
          set({ isLoading: true, error: null });
          try {
            logger.debug('Profile Store: Fetching profile...');
            const profile = await profileService.getProfile();

            set({ profile, isLoading: false });

            logger.success('Profile Store: Profile fetched');
          } catch (error: any) {
            const errorMsg = error.response?.data?.message || 'Failed to fetch profile';

            logger.error('Profile Store: Fetch profile failed:', error);

            set({
              error: errorMsg,
              isLoading: false
            });

            // Silent error - no toast for background fetch
          }
        },

        // Update profile
        updateProfile: async (data) => {
          set({ isLoading: true, error: null });
          try {
            logger.debug('Profile Store: Updating profile...');
            const profile = await profileService.updateProfile(data);

            toastHelper.success('Profile updated successfully!');

            set({ profile, isLoading: false });

            logger.success('Profile Store: Profile updated');
          } catch (error: any) {
            const errorMsg = error.response?.data?.message || 'Failed to update profile';

            logger.error('Profile Store: Update profile failed:', error);
            toastHelper.error(errorMsg);

            set({
              error: errorMsg,
              isLoading: false
            });
            throw error;
          }
        },

        // Change password
        changePassword: async (data) => {
          set({ isLoading: true, error: null });
          try {
            logger.debug('Profile Store: Changing password...');
            await profileService.changePassword(data);

            toastHelper.success('Password changed successfully!');

            set({ isLoading: false });

            logger.success('Profile Store: Password changed');
          } catch (error: any) {
            const errorMsg = error.response?.data?.message || 'Failed to change password';

            logger.error('Profile Store: Change password failed:', error);
            toastHelper.error(errorMsg);

            set({
              error: errorMsg,
              isLoading: false
            });
            throw error;
          }
        },

        // Update privacy
        updatePrivacy: async (data) => {
          set({ isLoading: true, error: null });
          try {
            logger.debug('Profile Store: Updating privacy settings...');
            const settings = await profileService.updatePrivacy(data);

            toastHelper.success('Privacy settings updated!');

            set({ settings, isLoading: false });

            logger.success('Profile Store: Privacy updated');
          } catch (error: any) {
            const errorMsg = error.response?.data?.message || 'Failed to update privacy';

            logger.error('Profile Store: Update privacy failed:', error);
            toastHelper.error(errorMsg);

            set({
              error: errorMsg,
              isLoading: false
            });
            throw error;
          }
        },

        // Set profile
        setProfile: (profile) => {
          logger.debug('Profile Store: Setting profile manually');
          set({ profile });
        },

        // Set settings
        setSettings: (settings) => {
          logger.debug('Profile Store: Setting settings manually');
          set({ settings });
        },

        // Clear error
        clearError: () => {
          set({ error: null });
        },

        // Reset store
        reset: () => {
          logger.debug('Profile Store: Reset');
          set({
            profile: null,
            settings: null,
            isLoading: false,
            error: null,
          });
        },
      }),
      {
        name: 'profile-storage',
        partialize: (state) => ({
          profile: state.profile,
          settings: state.settings
        }),
      }
    ),
    { name: 'ProfileStore' }
  )
);

================================================
FILE: src/features/profile/types/profile.types.ts
================================================

// ================================================
// FILE: src/features/profile/types/profile.types.ts
// Profile Types - Profile & Settings types
// ================================================

import type { Gender } from '@/shared/types/user-types';

// Privacy Enums
export enum LastSeenPrivacy {
  EVERYONE = 'EVERYONE',
  CONTACTS = 'CONTACTS',
  NOBODY = 'NOBODY',
}

export enum ProfilePhotoPrivacy {
  EVERYONE = 'EVERYONE',
  CONTACTS = 'CONTACTS',
  NOBODY = 'NOBODY',
}

export enum AboutPrivacy {
  EVERYONE = 'EVERYONE',
  CONTACTS = 'CONTACTS',
  NOBODY = 'NOBODY',
}

// Update Profile Input
export interface UpdateProfileInput {
  name?: string;
  about?: string;
  gender?: Gender;
  avatar?: string;
  profilePhoto?: string;
}

// Change Password Input
export interface ChangePasswordInput {
  currentPassword: string;
  newPassword: string;
}

// Update Privacy Input
export interface UpdatePrivacyInput {
  showOnlineStatus?: boolean;
  showLastSeen?: LastSeenPrivacy;
  showProfilePhoto?: ProfilePhotoPrivacy;
  showAbout?: AboutPrivacy;
  showStatus?: string;
}

// User Settings
export interface UserSettings {
  id: string;
  userId: string;

  // Privacy
  showOnlineStatus: boolean;
  showLastSeen: LastSeenPrivacy;
  showProfilePhoto: ProfilePhotoPrivacy;
  showAbout: AboutPrivacy;
  showStatus: string;

  // Notifications
  messageNotifications: boolean;
  soundEnabled: boolean;
  vibrationEnabled: boolean;
  showPreview: boolean;
  notificationTone: string;
  callNotifications: boolean;
  callRingtone: string;

  createdAt: string;
  updatedAt: string;
}

// Session
export interface Session {
  id: string;
  userId: string;
  deviceName: string;
  deviceType: string;
  ipAddress: string;
  userAgent: string;
  isActive: boolean;
  lastActiveAt: string;
  expiresAt: string;
  createdAt: string;
  updatedAt: string;
}

================================================
FILE: src/features/status/components/index.ts
================================================

// ================================================
// FILE: src/features/status/components/index.ts
// Export status components
// ================================================

export { StatusCard } from './status-card';
export { StatusViewer } from './status-viewer';
export { StatusUploadModal } from './status-upload-modal';


================================================
FILE: src/features/status/components/status-card.tsx
================================================

// ================================================
// FILE: src/features/status/components/status-card.tsx
// StatusCard Component - Status/Story card
// ================================================

import { UserAvatar } from '@/shared/components/common/user-avatar';
import { dateFormatter } from '@/shared/utils/date-formatter';
import { cn } from '@/shared/utils/cn';
import type { StatusWithDetails } from '../types/status.types';

interface StatusCardProps {
  status: StatusWithDetails;
  onClick?: () => void;
  viewed?: boolean;
}

export const StatusCard = ({ status, onClick, viewed }: StatusCardProps) => {
  return (
    <div
      onClick={onClick}
      className="flex cursor-pointer items-center gap-3 p-3 rounded-lg transition-colors hover:bg-muted/50"
    >
      {/* Avatar with ring */}
      <div className={cn(
        'relative rounded-full p-0.5',
        !viewed && 'bg-gradient-to-tr from-yellow-400 via-red-500 to-pink-500'
      )}>
        <div className="rounded-full bg-background p-0.5">
          <UserAvatar
            src={status.user.avatar || status.user.profilePhoto}
            name={status.user.name}
            size="lg"
          />
        </div>
      </div>

      {/* Status Info */}
      <div className="flex-1 overflow-hidden">
        <h4 className={cn(
          'truncate font-semibold',
          !viewed ? 'text-foreground' : 'text-muted-foreground'
        )}>
          {status.user.name}
        </h4>

        <p className="truncate text-sm text-muted-foreground">
          {dateFormatter.relativeTime(status.createdAt)}
        </p>
      </div>

      {/* View Count (for own status) */}
      {status.viewCount > 0 && (
        <div className="text-right">
          <p className="text-sm font-semibold text-foreground">
            {status.viewCount}
          </p>
          <p className="text-xs text-muted-foreground">
            {status.viewCount === 1 ? 'view' : 'views'}
          </p>
        </div>
      )}
    </div>
  );
};

================================================
FILE: src/features/status/components/status-upload-modal.tsx
================================================

// ================================================
// FILE: src/features/status/components/status-upload-modal.tsx
// StatusUploadModal Component - Upload status/story
// ================================================

import { useState, useRef, ChangeEvent } from 'react';
import { X, Image, Type, Video } from 'lucide-react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/shared/components/ui/dialog';
import { Button } from '@/shared/components/ui/button';
import { Textarea } from '@/shared/components/ui/textarea';
import { Label } from '@/shared/components/ui/label';
import { useStatus } from '../hooks/use-status';
import { useMedia } from '@/features/media/hooks/use-media';
import { StatusType } from '../types/status.types';
import { LoadingSpinner } from '@/shared/components/common/loading-spinner';

interface StatusUploadModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

const BACKGROUND_COLORS = [
  '#3B82F6', // Blue
  '#EF4444', // Red
  '#10B981', // Green
  '#F59E0B', // Yellow
  '#8B5CF6', // Purple
  '#EC4899', // Pink
];

export const StatusUploadModal = ({
  open,
  onOpenChange,
}: StatusUploadModalProps) => {
  const { createStatus, isLoading } = useStatus();
  const { uploadFile, isUploading, uploadProgress } = useMedia();

  const [statusType, setStatusType] = useState<StatusType>(StatusType.TEXT);
  const [content, setContent] = useState('');
  const [backgroundColor, setBackgroundColor] = useState(BACKGROUND_COLORS[0]);
  const [mediaPreview, setMediaPreview] = useState<string | null>(null);
  const [mediaFile, setMediaFile] = useState<File | null>(null);

  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileSelect = (e: ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setMediaFile(file);

    // Create preview
    const reader = new FileReader();
    reader.onload = () => {
      setMediaPreview(reader.result as string);
    };
    reader.readAsDataURL(file);

    // Set type based on file
    if (file.type.startsWith('image/')) {
      setStatusType(StatusType.IMAGE);
    } else if (file.type.startsWith('video/')) {
      setStatusType(StatusType.VIDEO);
    }
  };

  const handleSubmit = async () => {
    try {
      let mediaUrl: string | undefined;

      // Upload media if exists
      if (mediaFile) {
        const media = await uploadFile(mediaFile);
        mediaUrl = media.url;
      }

      // Create status
      await createStatus({
        type: statusType,
        content: content || undefined,
        mediaUrl,
        backgroundColor: statusType === StatusType.TEXT ? backgroundColor : undefined,
      });

      // Reset form
      resetForm();
      onOpenChange(false);
    } catch (error) {
      console.error('Failed to create status:', error);
    }
  };

  const resetForm = () => {
    setStatusType(StatusType.TEXT);
    setContent('');
    setBackgroundColor(BACKGROUND_COLORS[0]);
    setMediaPreview(null);
    setMediaFile(null);
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Create Status</DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          {/* Type Selection */}
          <div className="flex gap-2">
            <Button
              type="button"
              variant={statusType === StatusType.TEXT ? 'default' : 'outline'}
              onClick={() => {
                setStatusType(StatusType.TEXT);
                setMediaPreview(null);
                setMediaFile(null);
              }}
              className="flex-1"
            >
              <Type className="mr-2 h-4 w-4" />
              Text
            </Button>

            <Button
              type="button"
              variant={statusType === StatusType.IMAGE ? 'default' : 'outline'}
              onClick={() => fileInputRef.current?.click()}
              className="flex-1"
            >
              <Image className="mr-2 h-4 w-4" />
              Image
            </Button>

            <Button
              type="button"
              variant={statusType === StatusType.VIDEO ? 'default' : 'outline'}
              onClick={() => fileInputRef.current?.click()}
              className="flex-1"
            >
              <Video className="mr-2 h-4 w-4" />
              Video
            </Button>
          </div>

          {/* Hidden File Input */}
          <input
            ref={fileInputRef}
            type="file"
            accept="image/*,video/*"
            onChange={handleFileSelect}
            className="hidden"
          />

          {/* Media Preview */}
          {mediaPreview && (
            <div className="relative">
              {statusType === StatusType.IMAGE && (
                <img
                  src={mediaPreview}
                  alt="Preview"
                  className="w-full max-h-64 object-contain rounded-lg"
                />
              )}
              {statusType === StatusType.VIDEO && (
                <video
                  src={mediaPreview}
                  controls
                  className="w-full max-h-64 rounded-lg"
                />
              )}
              <Button
                type="button"
                size="icon"
                variant="destructive"
                onClick={() => {
                  setMediaPreview(null);
                  setMediaFile(null);
                  setStatusType(StatusType.TEXT);
                }}
                className="absolute top-2 right-2"
              >
                <X className="h-4 w-4" />
              </Button>
            </div>
          )}

          {/* Text Content */}
          {statusType === StatusType.TEXT && (
            <>
              <div className="space-y-2">
                <Label>Status Text</Label>
                <Textarea
                  value={content}
                  onChange={(e) => setContent(e.target.value)}
                  placeholder="What's on your mind?"
                  className="min-h-32"
                  maxLength={200}
                />
                <p className="text-xs text-muted-foreground text-right">
                  {content.length}/200
                </p>
              </div>

              {/* Background Color Selector */}
              <div className="space-y-2">
                <Label>Background Color</Label>
                <div className="flex gap-2">
                  {BACKGROUND_COLORS.map((color) => (
                    <button
                      key={color}
                      type="button"
                      onClick={() => setBackgroundColor(color)}
                      className="h-10 w-10 rounded-full border-2 transition-all"
                      style={{
                        backgroundColor: color,
                        borderColor: backgroundColor === color ? '#fff' : 'transparent',
                        transform: backgroundColor === color ? 'scale(1.1)' : 'scale(1)',
                      }}
                    />
                  ))}
                </div>
              </div>

              {/* Preview */}
              <div
                className="rounded-lg p-6 text-center"
                style={{ backgroundColor }}
              >
                <p className="text-white font-semibold">
                  {content || 'Your status preview...'}
                </p>
              </div>
            </>
          )}

          {/* Upload Progress */}
          {isUploading && (
            <div className="space-y-2">
              <div className="flex items-center justify-between text-sm">
                <span>Uploading...</span>
                <span>{uploadProgress}%</span>
              </div>
              <div className="h-2 bg-muted rounded-full overflow-hidden">
                <div
                  className="h-full bg-primary transition-all"
                  style={{ width: `${uploadProgress}%` }}
                />
              </div>
            </div>
          )}

          {/* Actions */}
          <div className="flex gap-2">
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
              className="flex-1"
              disabled={isLoading || isUploading}
            >
              Cancel
            </Button>

            <Button
              type="button"
              onClick={handleSubmit}
              className="flex-1"
              disabled={
                isLoading ||
                isUploading ||
                (statusType === StatusType.TEXT && !content.trim()) ||
                (statusType !== StatusType.TEXT && !mediaFile)
              }
            >
              {isLoading ? (
                <>
                  <LoadingSpinner size="sm" className="mr-2" />
                  Creating...
                </>
              ) : (
                'Create Status'
              )}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};

================================================
FILE: src/features/status/components/status-viewer.tsx
================================================

// ================================================
// FILE: src/features/status/components/status-viewer.tsx
// StatusViewer Component - Full screen status viewer
// ================================================

import { useState, useEffect } from 'react';
import { X, ChevronLeft, ChevronRight } from 'lucide-react';
import { UserAvatar } from '@/shared/components/common/user-avatar';
import { Button } from '@/shared/components/ui/button';
import { dateFormatter } from '@/shared/utils/date-formatter';
import type { StatusWithDetails } from '../types/status.types';

interface StatusViewerProps {
  statuses: StatusWithDetails[];
  initialIndex?: number;
  onClose: () => void;
  onView?: (statusId: string) => void;
}

export const StatusViewer = ({
  statuses,
  initialIndex = 0,
  onClose,
  onView,
}: StatusViewerProps) => {
  const [currentIndex, setCurrentIndex] = useState(initialIndex);
  const [progress, setProgress] = useState(0);

  const currentStatus = statuses[currentIndex];
  const isFirst = currentIndex === 0;
  const isLast = currentIndex === statuses.length - 1;

  // Auto progress
  useEffect(() => {
    const duration = 5000; // 5 seconds
    const interval = 50;
    let elapsed = 0;

    const timer = setInterval(() => {
      elapsed += interval;
      setProgress((elapsed / duration) * 100);

      if (elapsed >= duration) {
        if (!isLast) {
          handleNext();
        } else {
          onClose();
        }
      }
    }, interval);

    // Mark as viewed
    if (currentStatus && onView) {
      onView(currentStatus.id);
    }

    return () => clearInterval(timer);
  }, [currentIndex, currentStatus, isLast, onClose, onView]);

  const handlePrevious = () => {
    if (!isFirst) {
      setCurrentIndex(currentIndex - 1);
      setProgress(0);
    }
  };

  const handleNext = () => {
    if (!isLast) {
      setCurrentIndex(currentIndex + 1);
      setProgress(0);
    }
  };

  if (!currentStatus) return null;

  return (
    <div className="fixed inset-0 z-50 bg-black">
      {/* Progress bars */}
      <div className="absolute top-0 left-0 right-0 flex gap-1 p-2">
        {statuses.map((_, index) => (
          <div
            key={index}
            className="h-1 flex-1 overflow-hidden rounded-full bg-white/30"
          >
            <div
              className="h-full bg-white transition-all"
              style={{
                width: index === currentIndex ? `${progress}%` : index < currentIndex ? '100%' : '0%',
              }}
            />
          </div>
        ))}
      </div>

      {/* Header */}
      <div className="absolute top-4 left-0 right-0 flex items-center justify-between px-4 pt-4">
        <div className="flex items-center gap-3">
          <UserAvatar
            src={currentStatus.user.avatar}
            name={currentStatus.user.name}
            size="md"
          />
          <div>
            <h3 className="font-semibold text-white">
              {currentStatus.user.name}
            </h3>
            <p className="text-sm text-white/80">
              {dateFormatter.relativeTime(currentStatus.createdAt)}
            </p>
          </div>
        </div>

        <Button
          variant="ghost"
          size="icon"
          onClick={onClose}
          className="text-white hover:bg-white/20"
        >
          <X className="h-6 w-6" />
        </Button>
      </div>

      {/* Status Content */}
      <div className="flex h-full items-center justify-center p-4">
        {currentStatus.type === 'TEXT' && (
          <div
            className="max-w-2xl rounded-lg p-8 text-center"
            style={{ backgroundColor: currentStatus.backgroundColor }}
          >
            <p className="text-2xl font-semibold text-white">
              {currentStatus.content}
            </p>
          </div>
        )}

        {currentStatus.type === 'IMAGE' && currentStatus.mediaUrl && (
          <img
            src={currentStatus.mediaUrl}
            alt="Status"
            className="max-h-full max-w-full object-contain"
          />
        )}

        {currentStatus.type === 'VIDEO' && currentStatus.mediaUrl && (
          <video
            src={currentStatus.mediaUrl}
            autoPlay
            loop
            className="max-h-full max-w-full"
          />
        )}
      </div>

      {/* Navigation */}
      <div className="absolute inset-y-0 left-0 flex items-center">
        {!isFirst && (
          <Button
            variant="ghost"
            size="icon"
            onClick={handlePrevious}
            className="ml-4 text-white hover:bg-white/20"
          >
            <ChevronLeft className="h-8 w-8" />
          </Button>
        )}
      </div>

      <div className="absolute inset-y-0 right-0 flex items-center">
        {!isLast && (
          <Button
            variant="ghost"
            size="icon"
            onClick={handleNext}
            className="mr-4 text-white hover:bg-white/20"
          >
            <ChevronRight className="h-8 w-8" />
          </Button>
        )}
      </div>
    </div>
  );
};

================================================
FILE: src/features/status/hooks/use-status.ts
================================================

// ================================================
// FILE: src/features/status/hooks/use-status.ts
// useStatus Hook - Handle status/story logic (CLEANED)
// ================================================

import { useEffect } from 'react';
import { useStatusStore } from '../store/status.store';
import { logger } from '@/shared/utils/logger';
import type { CreateStatusInput, UpdateStatusPrivacyInput } from '../types/status.types';

// ‚úÖ GLOBAL FLAGS (outside React component lifecycle)
let GLOBAL_STATUS_FETCHED = false;

export const useStatus = () => {
  const {
    contactsStatuses,
    myStatuses,
    activeStatus,
    statusViews,
    isLoading,
    error,
    fetchContactsStatuses,
    fetchMyStatuses,
    createStatus,
    deleteStatus,
    viewStatus,
    fetchStatusViews,
    updatePrivacy,
    setActiveStatus,
    clearError,
  } = useStatusStore();

  // ‚úÖ Fetch statuses on mount (ONLY ONCE using global flag)
  useEffect(() => {
    if (!GLOBAL_STATUS_FETCHED) {
      logger.debug('useStatus: Fetching initial data...');
      fetchContactsStatuses();
      fetchMyStatuses();
      GLOBAL_STATUS_FETCHED = true; // ‚úÖ Set global flag
    }
  }, [fetchContactsStatuses, fetchMyStatuses]);

  // Create status
  const handleCreateStatus = async (data: CreateStatusInput) => {
    try {
      logger.debug('useStatus: Creating status...');
      await createStatus(data);
      logger.success('useStatus: Status created successfully');
    } catch (error) {
      logger.error('useStatus: Failed to create status:', error);
      throw error;
    }
  };

  // Delete status
  const handleDeleteStatus = async (statusId: string) => {
    try {
      logger.debug('useStatus: Deleting status:', statusId);
      await deleteStatus(statusId);
      logger.success('useStatus: Status deleted successfully');
    } catch (error) {
      logger.error('useStatus: Failed to delete status:', error);
      throw error;
    }
  };

  // View status
  const handleViewStatus = async (statusId: string) => {
    try {
      logger.debug('useStatus: Viewing status:', statusId);
      await viewStatus(statusId);
      // Silent - no success log for viewing
    } catch (error) {
      logger.warn('useStatus: Failed to view status:', error);
    }
  };

  // Get status views
  const handleFetchStatusViews = async (statusId: string) => {
    try {
      logger.debug('useStatus: Fetching status views:', statusId);
      await fetchStatusViews(statusId);
      logger.success('useStatus: Status views fetched successfully');
    } catch (error) {
      logger.error('useStatus: Failed to fetch status views:', error);
      throw error;
    }
  };

  // Update privacy
  const handleUpdatePrivacy = async (statusId: string, data: UpdateStatusPrivacyInput) => {
    try {
      logger.debug('useStatus: Updating privacy:', statusId);
      await updatePrivacy(statusId, data);
      logger.success('useStatus: Privacy updated successfully');
    } catch (error) {
      logger.error('useStatus: Failed to update privacy:', error);
      throw error;
    }
  };

  return {
    contactsStatuses,
    myStatuses,
    activeStatus,
    statusViews,
    isLoading,
    error,
    createStatus: handleCreateStatus,
    deleteStatus: handleDeleteStatus,
    viewStatus: handleViewStatus,
    fetchStatusViews: handleFetchStatusViews,
    updatePrivacy: handleUpdatePrivacy,
    setActiveStatus,
    clearError,
  };
};

// ‚úÖ EXPORT: Reset function for logout
export const resetStatusFetch = () => {
  GLOBAL_STATUS_FETCHED = false;
  logger.debug('useStatus: Reset fetch flag');
};

================================================
FILE: src/features/status/pages/status-page.tsx
================================================

// ================================================
// FILE: src/features/status/pages/status-page.tsx
// StatusPage - Status/Story page (CLEANED)
// ================================================

import { useState } from 'react';
import { Plus, Camera } from 'lucide-react';
import { AppLayout } from '@/shared/components/layouts/app-layout';
import { PageLayout } from '@/shared/components/common/page-layout';
import { Button } from '@/shared/components/ui/button';
import { EmptyState } from '@/shared/components/common/empty-state';
import { LoadingSpinner } from '@/shared/components/common/loading-spinner';
import { StatusCard } from '../components/status-card';
import { StatusViewer } from '../components/status-viewer';
import { StatusUploadModal } from '../components/status-upload-modal';
import { useStatus } from '../hooks/use-status';
import { logger } from '@/shared/utils/logger';

export const StatusPage = () => {
  const {
    contactsStatuses,
    myStatuses,
    isLoading,
    viewStatus,
  } = useStatus();

  const [viewingStatuses, setViewingStatuses] = useState<any[] | null>(null);
  const [viewingIndex, setViewingIndex] = useState(0);
  const [showUploadModal, setShowUploadModal] = useState(false);

  const header = (
    <div className="flex items-center justify-between">
      <h1 className="text-2xl font-bold">Status</h1>
      <Button onClick={() => setShowUploadModal(true)}>
        <Plus className="mr-2 h-4 w-4" />
        Add Status
      </Button>
    </div>
  );

  const handleViewStatus = (statuses: any[], index: number) => {
    logger.debug('Status Page: Viewing status at index:', index);
    setViewingStatuses(statuses);
    setViewingIndex(index);
  };

  const handleCloseViewer = () => {
    logger.debug('Status Page: Closing status viewer');
    setViewingStatuses(null);
    setViewingIndex(0);
  };

  return (
    <AppLayout>
      <PageLayout header={header}>
        {isLoading ? (
          <div className="flex h-64 items-center justify-center">
            <LoadingSpinner text="Loading statuses..." />
          </div>
        ) : (
          <div className="space-y-6">
            {/* My Status */}
            <div>
              <h2 className="mb-3 text-lg font-semibold">My Status</h2>
              {myStatuses.length > 0 ? (
                <div className="space-y-2">
                  {myStatuses.map((status, index) => (
                    <StatusCard
                      key={status.id}
                      status={status}
                      onClick={() => handleViewStatus(myStatuses, index)}
                    />
                  ))}
                </div>
              ) : (
                <Button
                  variant="outline"
                  className="w-full"
                  onClick={() => setShowUploadModal(true)}
                >
                  <Camera className="mr-2 h-4 w-4" />
                  Create your first status
                </Button>
              )}
            </div>

            {/* Recent Updates */}
            <div>
              <h2 className="mb-3 text-lg font-semibold">Recent Updates</h2>
              {contactsStatuses.length > 0 ? (
                <div className="space-y-2">
                  {contactsStatuses.map((status, index) => (
                    <StatusCard
                      key={status.id}
                      status={status}
                      onClick={() => handleViewStatus(contactsStatuses, index)}
                    />
                  ))}
                </div>
              ) : (
                <EmptyState
                  icon={Camera}
                  title="No recent updates"
                  description="Status updates from your contacts will appear here"
                />
              )}
            </div>
          </div>
        )}
      </PageLayout>

      {/* Status Viewer */}
      {viewingStatuses && (
        <StatusViewer
          statuses={viewingStatuses}
          initialIndex={viewingIndex}
          onClose={handleCloseViewer}
          onView={viewStatus}
        />
      )}

      {/* Upload Modal */}
      <StatusUploadModal
        open={showUploadModal}
        onOpenChange={setShowUploadModal}
      />
    </AppLayout>
  );
};

================================================
FILE: src/features/status/services/status.service.ts
================================================

// ================================================
// FILE: src/features/status/services/status.service.ts
// Status Service - Handle all status API calls (CLEANED)
// ================================================

import { axiosClient } from '@/lib/axios-client';
import { API_ENDPOINTS } from '@/shared/constants/api-endpoints';
import { logger } from '@/shared/utils/logger';
import type { ApiResponse } from '@/shared/types/api-types';
import type {
  Status,
  StatusWithDetails,
  CreateStatusInput,
  UpdateStatusPrivacyInput,
  StatusView
} from '../types/status.types';

export const statusService = {
  // Create new status
  createStatus: async (data: CreateStatusInput): Promise<StatusWithDetails> => {
    logger.debug('Status Service: Creating status...');

    const response = await axiosClient.post<ApiResponse<StatusWithDetails>>(
      API_ENDPOINTS.STATUS.CREATE,
      data
    );

    logger.success('Status Service: Status created');

    return response.data.data!;
  },

  // Get contacts' statuses
  getContactsStatuses: async (): Promise<StatusWithDetails[]> => {
    logger.debug('Status Service: Getting contacts statuses...');

    const response = await axiosClient.get<ApiResponse<StatusWithDetails[]>>(
      API_ENDPOINTS.STATUS.LIST
    );

    logger.success('Status Service: Contacts statuses retrieved:', response.data.data?.length || 0);

    return response.data.data || [];
  },

  // Get my statuses
  getMyStatuses: async (): Promise<StatusWithDetails[]> => {
    logger.debug('Status Service: Getting my statuses...');

    const response = await axiosClient.get<ApiResponse<StatusWithDetails[]>>(
      API_ENDPOINTS.STATUS.MY
    );

    logger.success('Status Service: My statuses retrieved:', response.data.data?.length || 0);

    return response.data.data || [];
  },

  // Get status by ID
  getStatusById: async (statusId: string): Promise<StatusWithDetails> => {
    logger.debug('Status Service: Getting status by ID:', statusId);

    const response = await axiosClient.get<ApiResponse<StatusWithDetails>>(
      API_ENDPOINTS.STATUS.BY_ID(statusId)
    );

    logger.success('Status Service: Status retrieved');

    return response.data.data!;
  },

  // Mark status as viewed
  markAsViewed: async (statusId: string): Promise<StatusView> => {
    logger.debug('Status Service: Marking status as viewed:', statusId);

    const response = await axiosClient.post<ApiResponse<StatusView>>(
      API_ENDPOINTS.STATUS.VIEW(statusId)
    );

    logger.success('Status Service: Status marked as viewed');

    return response.data.data!;
  },

  // Get status views
  getStatusViews: async (statusId: string): Promise<StatusView[]> => {
    logger.debug('Status Service: Getting status views:', statusId);

    const response = await axiosClient.get<ApiResponse<StatusView[]>>(
      API_ENDPOINTS.STATUS.VIEWS(statusId)
    );

    logger.success('Status Service: Status views retrieved:', response.data.data?.length || 0);

    return response.data.data || [];
  },

  // Update status privacy
  updatePrivacy: async (
    statusId: string,
    data: UpdateStatusPrivacyInput
  ): Promise<StatusWithDetails> => {
    logger.debug('Status Service: Updating privacy:', statusId);

    const response = await axiosClient.patch<ApiResponse<StatusWithDetails>>(
      API_ENDPOINTS.STATUS.PRIVACY(statusId),
      data
    );

    logger.success('Status Service: Privacy updated');

    return response.data.data!;
  },

  // Delete status
  deleteStatus: async (statusId: string): Promise<void> => {
    logger.debug('Status Service: Deleting status:', statusId);

    await axiosClient.delete(API_ENDPOINTS.STATUS.DELETE(statusId));

    logger.success('Status Service: Status deleted');
  },
};

================================================
FILE: src/features/status/store/status.store.ts
================================================

// ================================================
// FILE: src/features/status/store/status.store.ts
// Status Store - Global status state (CLEANED)
// ================================================

import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { statusService } from '../services/status.service';
import { toastHelper } from '@/shared/utils/toast-helper';
import { logger } from '@/shared/utils/logger';
import type {
  StatusWithDetails,
  CreateStatusInput,
  UpdateStatusPrivacyInput,
  StatusView
} from '../types/status.types';

interface StatusState {
  // State
  contactsStatuses: StatusWithDetails[];
  myStatuses: StatusWithDetails[];
  activeStatus: StatusWithDetails | null;
  statusViews: StatusView[];
  isLoading: boolean;
  error: string | null;

  // Actions
  fetchContactsStatuses: () => Promise<void>;
  fetchMyStatuses: () => Promise<void>;
  createStatus: (data: CreateStatusInput) => Promise<void>;
  deleteStatus: (statusId: string) => Promise<void>;
  viewStatus: (statusId: string) => Promise<void>;
  fetchStatusViews: (statusId: string) => Promise<void>;
  updatePrivacy: (statusId: string, data: UpdateStatusPrivacyInput) => Promise<void>;
  setActiveStatus: (status: StatusWithDetails | null) => void;
  addStatus: (status: StatusWithDetails) => void;

  // Utils
  clearError: () => void;
  reset: () => void;
}

export const useStatusStore = create<StatusState>()(
  devtools(
    (set, get) => ({
      // Initial state
      contactsStatuses: [],
      myStatuses: [],
      activeStatus: null,
      statusViews: [],
      isLoading: false,
      error: null,

      // Fetch contacts' statuses
      fetchContactsStatuses: async () => {
        set({ isLoading: true, error: null });
        try {
          logger.debug('Status Store: Fetching contacts statuses...');
          const statuses = await statusService.getContactsStatuses();

          set({ contactsStatuses: statuses, isLoading: false });

          logger.success('Status Store: Contacts statuses fetched:', statuses.length);
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to fetch statuses';

          logger.error('Status Store: Fetch contacts statuses failed:', error);

          set({
            error: errorMsg,
            isLoading: false
          });

          // Silent error - no toast for background fetch
        }
      },

      // Fetch my statuses
      fetchMyStatuses: async () => {
        set({ isLoading: true, error: null });
        try {
          logger.debug('Status Store: Fetching my statuses...');
          const statuses = await statusService.getMyStatuses();

          set({ myStatuses: statuses, isLoading: false });

          logger.success('Status Store: My statuses fetched:', statuses.length);
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to fetch my statuses';

          logger.error('Status Store: Fetch my statuses failed:', error);

          set({
            error: errorMsg,
            isLoading: false
          });

          // Silent error - no toast for background fetch
        }
      },

      // Create status
      createStatus: async (data) => {
        set({ isLoading: true, error: null });
        try {
          logger.debug('Status Store: Creating status...');
          const status = await statusService.createStatus(data);

          toastHelper.success('Status created successfully!');

          set((state) => ({
            myStatuses: [status, ...state.myStatuses],
            isLoading: false,
          }));

          logger.success('Status Store: Status created');
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to create status';

          logger.error('Status Store: Create status failed:', error);
          toastHelper.error(errorMsg);

          set({
            error: errorMsg,
            isLoading: false
          });
          throw error;
        }
      },

      // Delete status
      deleteStatus: async (statusId) => {
        try {
          logger.debug('Status Store: Deleting status:', statusId);
          await statusService.deleteStatus(statusId);

          toastHelper.success('Status deleted successfully');

          set((state) => ({
            myStatuses: state.myStatuses.filter((s) => s.id !== statusId),
            contactsStatuses: state.contactsStatuses.filter((s) => s.id !== statusId),
            activeStatus: state.activeStatus?.id === statusId ? null : state.activeStatus,
          }));

          logger.success('Status Store: Status deleted');
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to delete status';

          logger.error('Status Store: Delete status failed:', error);
          toastHelper.error(errorMsg);

          set({ error: errorMsg });
          throw error;
        }
      },

      // View status
      viewStatus: async (statusId) => {
        try {
          logger.debug('Status Store: Viewing status:', statusId);
          await statusService.markAsViewed(statusId);

          // Update view count
          set((state) => ({
            contactsStatuses: state.contactsStatuses.map((s) =>
              s.id === statusId
                ? { ...s, viewCount: (s.viewCount || 0) + 1 }
                : s
            ),
          }));

          // Silent - no toast for viewing
        } catch (error: any) {
          logger.warn('Status Store: Failed to mark status as viewed:', error);
          // Silent error
        }
      },

      // Fetch status views
      fetchStatusViews: async (statusId) => {
        set({ isLoading: true, error: null });
        try {
          logger.debug('Status Store: Fetching status views:', statusId);
          const views = await statusService.getStatusViews(statusId);

          set({ statusViews: views, isLoading: false });

          logger.success('Status Store: Status views fetched:', views.length);
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to fetch views';

          logger.error('Status Store: Fetch status views failed:', error);

          set({
            error: errorMsg,
            isLoading: false
          });

          // Silent error - no toast for background fetch
        }
      },

      // Update privacy
      updatePrivacy: async (statusId, data) => {
        try {
          logger.debug('Status Store: Updating privacy:', statusId);
          const updated = await statusService.updatePrivacy(statusId, data);

          toastHelper.success('Privacy updated successfully');

          set((state) => ({
            myStatuses: state.myStatuses.map((s) =>
              s.id === statusId ? updated : s
            ),
          }));

          logger.success('Status Store: Privacy updated');
        } catch (error: any) {
          const errorMsg = error.response?.data?.message || 'Failed to update privacy';

          logger.error('Status Store: Update privacy failed:', error);
          toastHelper.error(errorMsg);

          set({ error: errorMsg });
          throw error;
        }
      },

      // Set active status
      setActiveStatus: (status) => {
        logger.debug('Status Store: Setting active status:', status?.id);
        set({ activeStatus: status });
      },

      // Add status (from socket)
      addStatus: (status) => {
        logger.debug('Status Store: Adding status from socket:', status.id);
        set((state) => ({
          contactsStatuses: [status, ...state.contactsStatuses],
        }));
      },

      // Clear error
      clearError: () => {
        set({ error: null });
      },

      // Reset store
      reset: () => {
        logger.debug('Status Store: Reset');
        set({
          contactsStatuses: [],
          myStatuses: [],
          activeStatus: null,
          statusViews: [],
          isLoading: false,
          error: null,
        });
      },
    }),
    { name: 'StatusStore' }
  )
);

================================================
FILE: src/features/status/types/status.types.ts
================================================

// ================================================
// FILE: src/features/status/types/status.types.ts
// Status Types - Status/Story related types
// ================================================

import type { User } from '@/shared/types/user-types';

// Status Type
export enum StatusType {
  TEXT = 'TEXT',
  IMAGE = 'IMAGE',
  VIDEO = 'VIDEO',
}

// Status Privacy Type
export enum StatusPrivacyType {
  ALL = 'ALL',
  CONTACTS = 'CONTACTS',
  EXCEPT = 'EXCEPT',
}

// Base Status
export interface Status {
  id: string;
  userId: string;
  type: StatusType;
  content: string | null;
  mediaUrl: string | null;
  backgroundColor: string;
  viewCount: number;
  expiresAt: string;
  createdAt: string;
  updatedAt: string;
}

// Status with user details
export interface StatusWithDetails extends Status {
  user: {
    id: string;
    name: string;
    username: string | null;
    avatar: string | null;
    profilePhoto: string | null;
  };
  views?: Array<{
    id: string;
    viewedAt: string;
    viewer: {
      id: string;
      name: string;
      username: string | null;
      avatar: string | null;
    };
  }>;
  privacy?: StatusPrivacy | null;
}

// Status Privacy
export interface StatusPrivacy {
  id: string;
  statusId: string;
  type: StatusPrivacyType;
  exceptUserIds: string[];
  onlyUserIds: string[];
  createdAt: string;
  updatedAt: string;
}

// Status View
export interface StatusView {
  id: string;
  statusId: string;
  viewerId: string;
  viewedAt: string;
  viewer?: {
    id: string;
    name: string;
    username: string | null;
    avatar: string | null;
  };
}

// Create Status Input
export interface CreateStatusInput {
  type: StatusType;
  content?: string;
  mediaUrl?: string;
  backgroundColor?: string;
}

// Update Status Privacy Input
export interface UpdateStatusPrivacyInput {
  type: StatusPrivacyType;
  exceptUserIds?: string[];
  onlyUserIds?: string[];
}

================================================
FILE: src/features/user/services/user.service.ts
================================================

// ================================================
// FILE: src/features/user/services/user.service.ts
// User Service - Handle all user-related API calls (FIXED)
// ================================================

import { axiosClient } from '@/lib/axios-client';
import { API_ENDPOINTS } from '@/shared/constants/api-endpoints';
import type { User } from '@/shared/types/user-types';

export const userService = {
  // Get all users (for search/discovery)
  getAllUsers: async (): Promise<User[]> => {
    try {
      console.log('üîç Fetching all users from:', API_ENDPOINTS.USER.ALL);

      const response = await axiosClient.get(API_ENDPOINTS.USER.ALL);

      console.log('üì¶ Raw response:', response.data);

      // ‚úÖ FIXED: Handle both response formats
      // Backend format 1: { data: [...] }
      // Backend format 2: { users: [...] }
      const users = response.data.data || response.data.users || [];

      console.log('‚úÖ Parsed users:', users.length);

      // Ensure it's an array
      if (!Array.isArray(users)) {
        console.error('‚ùå Response is not an array:', users);
        return [];
      }

      return users;
    } catch (error: any) {
      console.error('‚ùå Failed to fetch users:', error);
      console.error('Response:', error.response?.data);
      return [];
    }
  },

  // Get user by ID
  getUserById: async (userId: string): Promise<User> => {
    try {
      console.log('üîç Fetching user by ID:', userId);

      const response = await axiosClient.get(API_ENDPOINTS.USER.BY_ID(userId));

      console.log('üì¶ Response:', response.data);

      // ‚úÖ FIXED: Handle both response formats
      const user = response.data.data || response.data.user;

      if (!user) {
        throw new Error('User not found in response');
      }

      return user;
    } catch (error: any) {
      console.error('‚ùå Failed to fetch user:', error);
      throw error;
    }
  },

  // Search user by username or email
  searchUser: async (query: string): Promise<User> => {
    try {
      console.log('üîç Searching user:', query);

      const response = await axiosClient.get(API_ENDPOINTS.USER.SEARCH(query));

      console.log('üì¶ Response:', response.data);

      // ‚úÖ FIXED: Handle both response formats
      const user = response.data.data || response.data.user;

      if (!user) {
        throw new Error('User not found');
      }

      return user;
    } catch (error: any) {
      console.error('‚ùå Failed to search user:', error);
      throw error;
    }
  },
};

================================================
FILE: src/hooks/index.ts
================================================

// ================================================
// FILE: src/hooks/index.ts
// Central export for all custom hooks
// ================================================

// Auth
export { useAuth } from '@/features/auth/hooks/use-auth';

// Chat
export { useChat } from '@/features/chat/hooks/use-chat';
export { useChatSocket } from '@/features/chat/hooks/use-chat-socket';

// Call
export { useCall } from '@/features/call/hooks/use-call';
export { useWebRTC } from '@/features/call/hooks/use-webrtc';

// Contacts
export { useContacts } from '@/features/contacts/hooks/use-contacts';

// Status
export { useStatus } from '@/features/status/hooks/use-status';

// Media
export { useMedia } from '@/features/media/hooks/use-media';

// Profile
export { useProfile } from '@/features/profile/hooks/use-profile';

================================================
FILE: src/lib/axios-client.ts
================================================

// ================================================
// FILE: src/lib/axios-client.ts
// HTTP Client Configuration with Interceptors
// ================================================

import axios, { AxiosError, InternalAxiosRequestConfig } from 'axios';

// Environment variable
const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000';
const API_PREFIX = '/api';

// Create axios instance
export const axiosClient = axios.create({
  baseURL: `${API_BASE_URL}${API_PREFIX}`,
  timeout: 30000,
  withCredentials: true, // Send cookies
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor
axiosClient.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    // üî• CRITICAL FIX: Get token FRESH every time from localStorage
    // Don't cache it, always read from storage at request time
    const token = localStorage.getItem('access_token');

    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
      console.log('üì§ API Request (with token):', {
        method: config.method?.toUpperCase(),
        url: config.url,
        hasToken: true,
        tokenPreview: token.substring(0, 20) + '...',
      });
    } else {
      console.log('üì§ API Request (no token):', {
        method: config.method?.toUpperCase(),
        url: config.url,
        hasToken: false,
      });
    }

    return config;
  },
  (error: AxiosError) => {
    console.error('‚ùå Request Error:', error);
    return Promise.reject(error);
  }
);

// Response interceptor
axiosClient.interceptors.response.use(
  (response) => {
    console.log('‚úÖ API Response:', {
      url: response.config.url,
      status: response.status,
      data: response.data,
    });
    return response;
  },
  (error: AxiosError) => {
    console.error('‚ùå Response Error:', {
      url: error.config?.url,
      status: error.response?.status,
      message: error.message,
    });

    // Handle specific error cases
    if (error.response?.status === 401) {
      console.warn('‚ö†Ô∏è 401 Unauthorized - Clearing token and redirecting...');

      // Clear token
      localStorage.removeItem('access_token');

      // Only redirect if not already on login page
      if (!window.location.pathname.includes('/auth/login')) {
        window.location.href = '/auth/login';
      }
    }

    return Promise.reject(error);
  }
);

================================================
FILE: src/lib/query-client.ts
================================================

// ================================================
// FILE: src/lib/query-client.ts
// React Query Configuration
// ================================================

// NOTE: Install @tanstack/react-query first
// pnpm add @tanstack/react-query

import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      refetchOnWindowFocus: false,
      staleTime: 5 * 60 * 1000, // 5 minutes
    },
    mutations: {
      retry: 0,
    },
  },
});

================================================
FILE: src/lib/socket-client.ts
================================================

// ================================================
// FILE: src/lib/socket-client.ts
// FIXED: Better connection state management to prevent duplicates
// ================================================

import { io, Socket } from 'socket.io-client';

const SOCKET_URL = import.meta.env.VITE_SOCKET_URL || 'http://localhost:8000';

class SocketClient {
  private socket: Socket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private isConnecting = false;
  private connectionPromise: Promise<Socket> | null = null;

  // Connect to socket server
  connect(token?: string): Socket {
    // ‚úÖ IMPROVED: Return existing connected socket
    if (this.socket?.connected) {
      console.log('‚úÖ Socket already connected:', this.socket.id);
      return this.socket;
    }

    // ‚úÖ IMPROVED: Wait for existing connection attempt
    if (this.isConnecting && this.socket) {
      console.log('‚è≥ Socket connection in progress, returning existing socket...');
      return this.socket;
    }

    const authToken = token || this.getTokenFromStorage();

    if (!authToken) {
      console.warn('‚ö†Ô∏è No auth token found');
      throw new Error('Authentication token required');
    }

    this.isConnecting = true;
    console.log('üîå Connecting to socket server...');

    // ‚úÖ IMPROVED: Disconnect existing socket before creating new one
    if (this.socket) {
      console.log('üîå Cleaning up existing socket before reconnect...');
      this.socket.removeAllListeners();
      this.socket.disconnect();
      this.socket = null;
    }

    this.socket = io(SOCKET_URL, {
      auth: { token: authToken },
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: this.maxReconnectAttempts,
      // ‚úÖ ADD: Prevent multiple connections
      forceNew: false,
      multiplex: true,
    });

    this.setupEventHandlers();

    return this.socket;
  }

  // Setup event handlers
  private setupEventHandlers(): void {
    if (!this.socket) return;

    this.socket.on('connect', () => {
      this.isConnecting = false;
      console.log('‚úÖ Socket connected:', this.socket?.id);
      this.reconnectAttempts = 0;
    });

    this.socket.on('disconnect', (reason) => {
      this.isConnecting = false;
      console.log('‚ùå Socket disconnected:', reason);

      // ‚úÖ ADD: Clean reconnection logic
      if (reason === 'io server disconnect') {
        // Server disconnected us, don't auto-reconnect
        console.log('üîå Server disconnected, not auto-reconnecting');
      }
    });

    this.socket.on('connect_error', (error) => {
      this.isConnecting = false;
      this.reconnectAttempts++;
      console.error(
        `‚ùå Connection error (attempt ${this.reconnectAttempts}):`,
        error.message
      );

      // ‚úÖ ADD: Stop trying after max attempts
      if (this.reconnectAttempts >= this.maxReconnectAttempts) {
        console.error('‚ùå Max reconnection attempts reached');
        this.socket?.disconnect();
      }
    });

    // ‚úÖ ADD: Handle reconnection
    this.socket.on('reconnect', (attemptNumber) => {
      console.log('‚úÖ Socket reconnected after', attemptNumber, 'attempts');
      this.reconnectAttempts = 0;
    });

    this.socket.on('reconnect_error', (error) => {
      console.error('‚ùå Reconnection error:', error.message);
    });

    this.socket.on('reconnect_failed', () => {
      console.error('‚ùå Reconnection failed after max attempts');
      this.isConnecting = false;
    });
  }

  // Disconnect from socket
  disconnect(): void {
    if (this.socket) {
      console.log('üîå Disconnecting socket...');
      this.socket.removeAllListeners();
      this.socket.disconnect();
      this.socket = null;
      this.reconnectAttempts = 0;
      this.isConnecting = false;
      this.connectionPromise = null;
    }
  }

  // Check if currently connecting
  isCurrentlyConnecting(): boolean {
    return this.isConnecting;
  }

  // Get socket instance
  getSocket(): Socket | null {
    return this.socket;
  }

  // Check if connected
  isConnected(): boolean {
    return this.socket?.connected || false;
  }

  // Emit event with connection check
  emit(event: string, data?: any): void {
    if (!this.socket?.connected) {
      console.error('‚ùå Socket not connected, cannot emit:', event);
      return;
    }
    this.socket.emit(event, data);
  }

  // Listen to event
  on(event: string, callback: (...args: any[]) => void): void {
    this.socket?.on(event, callback);
  }

  // Remove listener
  off(event: string, callback?: (...args: any[]) => void): void {
    this.socket?.off(event, callback);
  }

  // ‚úÖ ADD: Remove all listeners for an event
  removeAllListeners(event?: string): void {
    if (event) {
      this.socket?.removeAllListeners(event);
    } else {
      this.socket?.removeAllListeners();
    }
  }

  // Get token from storage
  private getTokenFromStorage(): string | null {
    return localStorage.getItem('access_token');
  }

  // ‚úÖ ADD: Force reconnect
  forceReconnect(token?: string): Socket {
    console.log('üîå Force reconnecting...');
    this.disconnect();
    return this.connect(token);
  }
}

export const socketClient = new SocketClient();

================================================
FILE: src/lib/utils.ts
================================================

// ================================================
// FILE: src/lib/utils
// ================================================

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


================================================
FILE: src/pages/index.ts
================================================

// ================================================
// FILE: src/pages/index.ts
// Central export for all pages (WITH ACTIVE CALL)
// ================================================

// Auth Pages
export { LoginPage } from '@/features/auth/pages/login-page';
export { RegisterPage } from '@/features/auth/pages/register-page';

// Chat Pages
export { ChatPage } from '@/features/chat/pages/chat-page';

// Call Pages
export { CallsPage } from '@/features/call/pages/calls-page';

// Contact Pages
export { ContactsPage } from '@/features/contacts/pages/contacts-page';

// Status Pages
export { StatusPage } from '@/features/status/pages/status-page';

// Profile Pages
export { ProfilePage } from '@/features/profile/pages/profile-page';

================================================
FILE: src/services/index.ts
================================================


// ================================================
// FILE: src/services/index.ts
// Central export for all services
// ================================================

// Auth
export { authService } from '@/features/auth/services/auth.service';

// Chat & Message
export { chatService } from '@/features/chat/services/chat.service';
export { messageService } from '@/features/chat/services/message.service';

// Call
export { callService } from '@/features/call/services/call.service';

// Contact & Friend Request
export { contactService } from '@/features/contacts/services/contact.service';
export { friendRequestService } from '@/features/contacts/services/friend-request.service';

// Status
export { statusService } from '@/features/status/services/status.service';

// Media
export { mediaService } from '@/features/media/services/media.service';

// Profile
export { profileService } from '@/features/profile/services/profile.service';

// User
export { userService } from '@/features/user/services/user.service';

================================================
FILE: src/shared/components/index.ts
================================================

// ================================================
// FILE: src/shared/components/index.ts
// Central export for common components
// ================================================

// Common Components
export { EmptyState } from '@/shared/components/common/empty-state';
export { LoadingSpinner, LoadingPage } from '@/shared/components/common/loading-spinner';
export { UserAvatar } from '@/shared/components/common/user-avatar';
export { SearchBar } from '@/shared/components/common/search-bar';
export { ErrorBoundary } from '@/shared/components/common/error-boundary';
export { PageLayout } from './common/page-layout';



================================================
FILE: src/shared/components/common/empty-state.tsx
================================================

// ================================================
// FILE: src/shared/components/common/empty-state.tsx
// EmptyState Component - Display when no data
// ================================================

import { ReactNode } from 'react';
import { LucideIcon } from 'lucide-react';
import { cn } from '@/shared/utils/cn';

interface EmptyStateProps {
  icon?: LucideIcon;
  title: string;
  description?: string;
  action?: ReactNode;
  className?: string;
}

export const EmptyState = ({
  icon: Icon,
  title,
  description,
  action,
  className,
}: EmptyStateProps) => {
  return (
    <div className={cn(
      'flex flex-col items-center justify-center py-12 px-4 text-center',
      className
    )}>
      {Icon && (
        <div className="mb-4 rounded-full bg-muted p-4">
          <Icon className="h-8 w-8 text-muted-foreground" />
        </div>
      )}

      <h3 className="text-lg font-semibold text-foreground mb-2">
        {title}
      </h3>

      {description && (
        <p className="text-sm text-muted-foreground max-w-sm mb-6">
          {description}
        </p>
      )}

      {action && <div>{action}</div>}
    </div>
  );
};

================================================
FILE: src/shared/components/common/error-boundary.tsx
================================================

// ================================================
// FILE: src/shared/components/common/error-boundary.tsx
// ErrorBoundary Component - Catch React errors
// ================================================

import React, { Component, ReactNode } from 'react';
import { AlertTriangle } from 'lucide-react';
import { Button } from '@/shared/components/ui/button';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
    };
  }

  static getDerivedStateFromError(error: Error): State {
    return {
      hasError: true,
      error,
    };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
  }

  handleReset = () => {
    this.setState({
      hasError: false,
      error: null,
    });
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="flex min-h-screen items-center justify-center p-4">
          <div className="text-center">
            <div className="mb-4 inline-flex rounded-full bg-destructive/10 p-4">
              <AlertTriangle className="h-8 w-8 text-destructive" />
            </div>

            <h2 className="mb-2 text-2xl font-bold text-foreground">
              Something went wrong
            </h2>

            <p className="mb-4 text-muted-foreground">
              {this.state.error?.message || 'An unexpected error occurred'}
            </p>

            <Button onClick={this.handleReset}>
              Try again
            </Button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

================================================
FILE: src/shared/components/common/loading-spinner.tsx
================================================

// ================================================
// FILE: src/shared/components/common/loading-spinner.tsx
// LoadingSpinner Component - Loading indicator
// ================================================

import { Loader2 } from 'lucide-react';
import { cn } from '@/shared/utils/cn';

interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg';
  className?: string;
  text?: string;
}

const sizeClasses = {
  sm: 'h-4 w-4',
  md: 'h-8 w-8',
  lg: 'h-12 w-12',
};

export const LoadingSpinner = ({
  size = 'md',
  className,
  text
}: LoadingSpinnerProps) => {
  return (
    <div className="flex flex-col items-center justify-center gap-2">
      <Loader2
        className={cn(
          'animate-spin text-primary',
          sizeClasses[size],
          className
        )}
      />
      {text && (
        <p className="text-sm text-muted-foreground">{text}</p>
      )}
    </div>
  );
};

// Full page loading
export const LoadingPage = ({ text = 'Loading...' }: { text?: string }) => {
  return (
    <div className="flex h-screen items-center justify-center">
      <LoadingSpinner size="lg" text={text} />
    </div>
  );
};

================================================
FILE: src/shared/components/common/page-layout.tsx
================================================

// ================================================
// FILE: src/shared/components/common/page-layout.tsx
// PageLayout Component - Reusable page wrapper
// ================================================

import { ReactNode } from 'react';
import { cn } from '@/shared/utils/cn';

interface PageLayoutProps {
  children: ReactNode;
  header?: ReactNode;
  footer?: ReactNode;
  className?: string;
  maxWidth?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
}

const maxWidthClasses = {
  sm: 'max-w-2xl',
  md: 'max-w-4xl',
  lg: 'max-w-6xl',
  xl: 'max-w-7xl',
  full: 'max-w-full',
};

export const PageLayout = ({
  children,
  header,
  footer,
  className,
  maxWidth = 'full',
}: PageLayoutProps) => {
  return (
    <div className="flex min-h-screen flex-col">
      {header && (
        <header className="sticky top-0 z-10 border-b bg-background">
          <div className={cn('mx-auto px-4 py-3', maxWidthClasses[maxWidth])}>
            {header}
          </div>
        </header>
      )}

      <main className={cn('flex-1', className)}>
        <div className={cn('mx-auto h-full px-4 py-6', maxWidthClasses[maxWidth])}>
          {children}
        </div>
      </main>

      {footer && (
        <footer className="border-t bg-background">
          <div className={cn('mx-auto px-4 py-4', maxWidthClasses[maxWidth])}>
            {footer}
          </div>
        </footer>
      )}
    </div>
  );
};

================================================
FILE: src/shared/components/common/search-bar.tsx
================================================

// ================================================
// FILE: src/shared/components/common/search-bar.tsx
// SearchBar Component - Search input with debounce
// ================================================

import { useState, useEffect } from 'react';
import { Search, X } from 'lucide-react';
import { Input } from '@/shared/components/ui/input';
import { Button } from '@/shared/components/ui/button';
import { cn } from '@/shared/utils/cn';

interface SearchBarProps {
  placeholder?: string;
  onSearch: (query: string) => void;
  debounceMs?: number;
  className?: string;
}

export const SearchBar = ({
  placeholder = 'Search...',
  onSearch,
  debounceMs = 300,
  className,
}: SearchBarProps) => {
  const [query, setQuery] = useState('');

  // Debounce search
  useEffect(() => {
    const timer = setTimeout(() => {
      onSearch(query);
    }, debounceMs);

    return () => clearTimeout(timer);
  }, [query, debounceMs, onSearch]);

  const handleClear = () => {
    setQuery('');
    onSearch('');
  };

  return (
    <div className={cn('relative', className)}>
      <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />

      <Input
        type="text"
        placeholder={placeholder}
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        className="pl-10 pr-10"
      />

      {query && (
        <Button
          variant="ghost"
          size="icon"
          onClick={handleClear}
          className="absolute right-1 top-1/2 h-7 w-7 -translate-y-1/2"
        >
          <X className="h-4 w-4" />
        </Button>
      )}
    </div>
  );
};

================================================
FILE: src/shared/components/common/user-avatar.tsx
================================================

// ================================================
// FILE: src/shared/components/common/user-avatar.tsx
// UserAvatar Component - User avatar with fallback
// ================================================

import { Avatar, AvatarFallback, AvatarImage } from '@/shared/components/ui/avatar';
import { cn } from '@/shared/utils/cn';
import { stringHelper } from '@/shared/utils/string-helper';

interface UserAvatarProps {
  src?: string | null;
  name: string;
  size?: 'sm' | 'md' | 'lg' | 'xl';
  className?: string;
  online?: boolean;
}

const sizeClasses = {
  sm: 'h-8 w-8 text-xs',
  md: 'h-10 w-10 text-sm',
  lg: 'h-12 w-12 text-base',
  xl: 'h-16 w-16 text-lg',
};

export const UserAvatar = ({
  src,
  name,
  size = 'md',
  className,
  online,
}: UserAvatarProps) => {
  const initials = stringHelper.getInitials(name);

  return (
    <div className="relative inline-block">
      <Avatar className={cn(sizeClasses[size], className)}>
        <AvatarImage src={src || undefined} alt={name} />
        <AvatarFallback className="bg-primary text-primary-foreground">
          {initials}
        </AvatarFallback>
      </Avatar>

      {online !== undefined && (
        <span
          className={cn(
            'absolute bottom-0 right-0 block rounded-full ring-2 ring-background',
            online ? 'bg-green-500' : 'bg-gray-400',
            size === 'sm' && 'h-2 w-2',
            size === 'md' && 'h-2.5 w-2.5',
            size === 'lg' && 'h-3 w-3',
            size === 'xl' && 'h-4 w-4'
          )}
        />
      )}
    </div>
  );
};

================================================
FILE: src/shared/components/layouts/index.ts
================================================

// ================================================
// FILE: src/shared/components/layouts/index.ts
// Central export for all layouts
// ================================================

export { AppLayout } from './app-layout';
export { DesktopSidebar } from './desktop-sidebar';
export { MobileBottomNav } from './mobile-bottom-nav';
export { AuthLayout } from './auth-layout';
export { ChatLayout } from './chat-layout';


================================================
FILE: src/shared/components/layouts/app-layout.tsx
================================================

// ================================================
// FILE: src/shared/components/layouts/app-layout.tsx
// AppLayout Component - WITH GLOBAL INCOMING CALL MODAL (FIXED)
// ================================================

import { ReactNode } from 'react';
import { useMediaQuery } from '@/shared/hooks/use-media-query';
import { DesktopSidebar } from './desktop-sidebar';
import { MobileBottomNav } from './mobile-bottom-nav';
import { IncomingCallModal } from '@/features/call/components/incoming-call-modal';
import { ActiveCallModal } from '@/features/call/components/active-call-modal';
import { useCall } from '@/features/call/hooks/use-call';
import { useCallStore } from '@/features/call/store/call.store';
import { cn } from '@/shared/utils/cn';
import { logger } from '@/shared/utils/logger';

interface AppLayoutProps {
  children: ReactNode;
  className?: string;
}

export const AppLayout = ({ children, className }: AppLayoutProps) => {
  const isDesktop = useMediaQuery('(min-width: 1024px)');

  // ‚úÖ Global incoming call handler
  const {
    incomingCall,
    activeCall,
    answerCall,
    rejectCall,
  } = useCall();

  // ‚úÖ Handle answer call
  const handleAnswerCall = async () => {
    if (!incomingCall) {
      logger.warn('AppLayout: No incoming call to answer');
      return;
    }

    try {
      logger.debug('AppLayout: Answering incoming call:', incomingCall.id);
      await answerCall(incomingCall.id);
      logger.success('AppLayout: Call answered successfully');
    } catch (error) {
      logger.error('AppLayout: Failed to answer call:', error);
    }
  };

  // ‚úÖ Handle reject call
  const handleRejectCall = async () => {
    if (!incomingCall) {
      logger.warn('AppLayout: No incoming call to reject');
      return;
    }

    try {
      logger.debug('AppLayout: Rejecting incoming call:', incomingCall.id);
      await rejectCall(incomingCall.id);
      logger.success('AppLayout: Call rejected successfully');
    } catch (error) {
      logger.error('AppLayout: Failed to reject call:', error);
    }
  };

  // ‚úÖ Handle close active call modal (reset state)
  const handleCloseActiveCall = () => {
    logger.debug('AppLayout: Closing active call modal');

    // Reset activeCall di store untuk close modal
    const { setActiveCall } = useCallStore.getState();
    setActiveCall(null);

    logger.success('AppLayout: Active call modal closed');
  };

  return (
    <>
      <div className="flex h-screen overflow-hidden bg-background">
        {/* Desktop Sidebar */}
        {isDesktop && <DesktopSidebar />}

        {/* Main Content */}
        <main
          className={cn(
            'flex-1 overflow-hidden',
            !isDesktop && 'pb-16', // Add padding for mobile bottom nav
            className
          )}
        >
          {children}
        </main>

        {/* Mobile Bottom Navigation */}
        {!isDesktop && <MobileBottomNav />}
      </div>

      {/* ‚úÖ GLOBAL INCOMING CALL MODAL */}
      <IncomingCallModal
        call={incomingCall}
        onAnswer={handleAnswerCall}
        onReject={handleRejectCall}
      />

      {/* ‚úÖ GLOBAL ACTIVE CALL MODAL (WITH PROPER CLOSE HANDLER) */}
      <ActiveCallModal
        open={!!activeCall}
        onClose={handleCloseActiveCall} // ‚Üê FIXED: Proper close handler
      />
    </>
  );
};

================================================
FILE: src/shared/components/layouts/auth-layout.tsx
================================================

// ================================================
// FILE: src/shared/components/layouts/auth-layout.tsx
// AuthLayout Component - Layout for login/register pages
// ================================================

import { ReactNode } from 'react';
import { MessageCircle } from 'lucide-react';

interface AuthLayoutProps {
  children: ReactNode;
  title: string;
  subtitle?: string;
}

export const AuthLayout = ({ children, title, subtitle }: AuthLayoutProps) => {
  return (
    <div className="flex min-h-screen items-center justify-center bg-gradient-to-br from-primary/10 via-background to-background p-4">
      <div className="w-full max-w-md space-y-8">
        {/* Logo & Header */}
        <div className="text-center">
          <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-2xl bg-primary">
            <MessageCircle className="h-8 w-8 text-primary-foreground" />
          </div>

          <h1 className="text-3xl font-bold text-foreground">
            {title}
          </h1>

          {subtitle && (
            <p className="mt-2 text-sm text-muted-foreground">
              {subtitle}
            </p>
          )}
        </div>

        {/* Content */}
        <div className="rounded-lg border bg-card p-8 shadow-sm">
          {children}
        </div>
      </div>
    </div>
  );
};

================================================
FILE: src/shared/components/layouts/chat-layout.tsx
================================================

// ================================================
// FILE: src/shared/components/layouts/chat-layout.tsx
// ChatLayout Component - Layout for chat pages
// ================================================

import { ReactNode } from 'react';
import { useMediaQuery } from '@/shared/hooks/use-media-query';
import { cn } from '@/shared/utils/cn';

interface ChatLayoutProps {
  sidebar: ReactNode;
  main: ReactNode;
  showSidebar?: boolean;
}

export const ChatLayout = ({
  sidebar,
  main,
  showSidebar = true
}: ChatLayoutProps) => {
  const isDesktop = useMediaQuery('(min-width: 768px)');

  // On mobile, show either sidebar or main based on showSidebar prop
  if (!isDesktop) {
    return (
      <div className="h-full">
        {showSidebar ? sidebar : main}
      </div>
    );
  }

  // On desktop, show both
  return (
    <div className="flex h-full">
      {/* Sidebar */}
      <div className="w-80 border-r bg-background overflow-y-auto">
        {sidebar}
      </div>

      {/* Main Content */}
      <div className="flex-1 bg-background">
        {main}
      </div>
    </div>
  );
};

================================================
FILE: src/shared/components/layouts/desktop-sidebar.tsx
================================================

// ================================================
// FILE: src/shared/components/layouts/desktop-sidebar.tsx
// DesktopSidebar Component - Desktop navigation sidebar
// ================================================

import { NavLink } from 'react-router-dom';
import {
  MessageCircle,
  Phone,
  Users,
  Camera,
  User,
  Settings,
  LogOut
} from 'lucide-react';
import { UserAvatar } from '@/shared/components/common/user-avatar';
import { Button } from '@/shared/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/shared/components/ui/dropdown-menu';
import { useAuth } from '@/features/auth/hooks/use-auth';
import { ROUTE_PATHS } from '@/shared/constants/route-paths';
import { cn } from '@/shared/utils/cn';

const navItems = [
  { path: ROUTE_PATHS.CHATS, icon: MessageCircle, label: 'Chats' },
  { path: ROUTE_PATHS.STATUS, icon: Camera, label: 'Status' },
  { path: ROUTE_PATHS.CALLS, icon: Phone, label: 'Calls' },
  { path: ROUTE_PATHS.CONTACTS, icon: Users, label: 'Contacts' },
];

export const DesktopSidebar = () => {
  const { user, logout } = useAuth();

  return (
    <aside className="flex w-20 flex-col items-center gap-4 border-r bg-background py-4">
      {/* Logo */}
      <div className="mb-4">
        <div className="flex h-12 w-12 items-center justify-center rounded-lg bg-primary">
          <MessageCircle className="h-6 w-6 text-primary-foreground" />
        </div>
      </div>

      {/* Navigation */}
      <nav className="flex flex-1 flex-col gap-2">
        {navItems.map((item) => (
          <NavLink
            key={item.path}
            to={item.path}
            className={({ isActive }) =>
              cn(
                'flex h-12 w-12 items-center justify-center rounded-lg transition-colors',
                'hover:bg-muted',
                isActive && 'bg-muted text-primary'
              )
            }
          >
            <item.icon className="h-6 w-6" />
          </NavLink>
        ))}
      </nav>

      {/* User Menu */}
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button
            variant="ghost"
            className="h-12 w-12 rounded-full p-0"
          >
            <UserAvatar
              src={user?.avatar}
              name={user?.name || 'User'}
              size="md"
              online={user?.isOnline}
            />
          </Button>
        </DropdownMenuTrigger>

        <DropdownMenuContent align="end" side="right" className="w-56">
          <div className="flex items-center gap-2 p-2">
            <UserAvatar
              src={user?.avatar}
              name={user?.name || 'User'}
              size="sm"
            />
            <div className="flex-1 overflow-hidden">
              <p className="truncate font-semibold text-sm">
                {user?.name}
              </p>
              <p className="truncate text-xs text-muted-foreground">
                {user?.email}
              </p>
            </div>
          </div>

          <DropdownMenuSeparator />

          <DropdownMenuItem asChild>
            <NavLink to={ROUTE_PATHS.PROFILE} className="cursor-pointer">
              <User className="mr-2 h-4 w-4" />
              Profile
            </NavLink>
          </DropdownMenuItem>

          <DropdownMenuItem asChild>
            <NavLink to={ROUTE_PATHS.SETTINGS} className="cursor-pointer">
              <Settings className="mr-2 h-4 w-4" />
              Settings
            </NavLink>
          </DropdownMenuItem>

          <DropdownMenuSeparator />

          <DropdownMenuItem
            onClick={logout}
            className="cursor-pointer text-destructive focus:text-destructive"
          >
            <LogOut className="mr-2 h-4 w-4" />
            Logout
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    </aside>
  );
};

================================================
FILE: src/shared/components/layouts/mobile-bottom-nav.tsx
================================================

// ================================================
// FILE: src/shared/components/layouts/mobile-bottom-nav.tsx
// MobileBottomNav Component - Mobile bottom navigation
// ================================================

import { NavLink } from 'react-router-dom';
import {
  MessageCircle,
  Phone,
  Users,
  Camera,
  User
} from 'lucide-react';
import { ROUTE_PATHS } from '@/shared/constants/route-paths';
import { cn } from '@/shared/utils/cn';

const navItems = [
  { path: ROUTE_PATHS.CHATS, icon: MessageCircle, label: 'Chats' },
  { path: ROUTE_PATHS.STATUS, icon: Camera, label: 'Status' },
  { path: ROUTE_PATHS.CALLS, icon: Phone, label: 'Calls' },
  { path: ROUTE_PATHS.CONTACTS, icon: Users, label: 'Contacts' },
  { path: ROUTE_PATHS.PROFILE, icon: User, label: 'Profile' },
];

export const MobileBottomNav = () => {
  return (
    <nav className="fixed bottom-0 left-0 right-0 z-50 border-t bg-background">
      <div className="flex items-center justify-around">
        {navItems.map((item) => (
          <NavLink
            key={item.path}
            to={item.path}
            className={({ isActive }) =>
              cn(
                'flex flex-col items-center gap-1 py-2 px-3 transition-colors',
                'hover:text-primary',
                isActive ? 'text-primary' : 'text-muted-foreground'
              )
            }
          >
            <item.icon className="h-6 w-6" />
            <span className="text-xs font-medium">{item.label}</span>
          </NavLink>
        ))}
      </div>
    </nav>
  );
};

================================================
FILE: src/shared/constants/api-endpoints.ts
================================================

// ================================================
// FILE: src/shared/constants/api-endpoints.ts
// API Endpoint Definitions
// ================================================

export const API_ENDPOINTS = {
  // Auth
  AUTH: {
    LOGIN: '/auth/login',
    REGISTER: '/auth/register',
    LOGOUT: '/auth/logout',
    STATUS: '/auth/status',
    REFRESH: '/auth/refresh',
  },

  // User
  USER: {
    ALL: '/user/all',
    BY_ID: (id: string) => `/user/${id}`,
    SEARCH: (query: string) => `/user/search/${query}`,
  },

  // Chat
  CHAT: {
    LIST: '/chats',
    CREATE: '/chats',
    BY_ID: (id: string) => `/chats/${id}`,
    DELETE: (id: string) => `/chats/${id}`,
  },

  // Message
  MESSAGE: {
    SEND: '/messages',
    BY_CHAT: (chatId: string) => `/messages/chat/${chatId}`,
    DELETE: (id: string) => `/messages/${id}`,
    EDIT: (id: string) => `/messages/${id}`,
    MARK_READ: (id: string) => `/messages/${id}/read`,
    STAR: (id: string) => `/messages/${id}/star`,
    FORWARD: (id: string) => `/messages/${id}/forward`,
    SEARCH: (chatId: string) => `/messages/search/${chatId}`,
  },

  // Call
  CALL: {
    INITIATE: '/calls/initiate',
    ANSWER: (id: string) => `/calls/${id}/answer`,
    END: (id: string) => `/calls/${id}/end`,
    REJECT: (id: string) => `/calls/${id}/reject`,
    HISTORY: '/calls/history',
    DELETE: (id: string) => `/calls/${id}`,
  },

  // Status
  STATUS: {
    CREATE: '/status',
    LIST: '/status',
    MY: '/status/my',
    BY_ID: (id: string) => `/status/${id}`,
    VIEW: (id: string) => `/status/${id}/view`,
    VIEWS: (id: string) => `/status/${id}/views`,
    PRIVACY: (id: string) => `/status/${id}/privacy`,
    DELETE: (id: string) => `/status/${id}`,
  },

  // Media
  MEDIA: {
    UPLOAD: '/media/upload',
    BY_ID: (id: string) => `/media/${id}`,
    USER_ALL: '/media/user/all',
    DELETE: (id: string) => `/media/${id}`,
  },

  // Contact
  CONTACT: {
    LIST: '/contacts',
    BLOCKED: '/contacts/blocked',
    BLOCK: '/contacts/block',
    UNBLOCK: '/contacts/unblock',
    REMOVE: (id: string) => `/contacts/${id}`,
    NICKNAME: '/contacts/nickname',
  },

  // Friend Request
  FRIEND_REQUEST: {
    SEND: '/friend-requests/send',
    PENDING: '/friend-requests/pending',
    SENT: '/friend-requests/sent',
    ACCEPT: (id: string) => `/friend-requests/${id}/accept`,
    REJECT: (id: string) => `/friend-requests/${id}/reject`,
    CANCEL: (id: string) => `/friend-requests/${id}/cancel`,
    STATUS: (userId: string) => `/friend-requests/status/${userId}`,
  },

  // Profile
  PROFILE: {
    GET: '/profile',
    UPDATE: '/profile',
    CHANGE_PASSWORD: '/profile/change-password',
    PRIVACY: '/profile/privacy',
  },

  // Settings
  SETTINGS: {
    GET: '/settings',
    NOTIFICATIONS: '/settings/notifications',
    SESSIONS: '/settings/sessions',
    REVOKE_SESSION: (id: string) => `/settings/sessions/${id}`,
  },
} as const;

================================================
FILE: src/shared/constants/app-config.ts
================================================

// ================================================
// FILE: src/shared/constants/app-config.ts
// Application-wide Constants
// ================================================

export const APP_CONFIG = {
  APP_NAME: 'Chat App Pro',
  APP_VERSION: '1.0.0',

  // API Configuration
  API_URL: import.meta.env.VITE_API_URL || 'http://localhost:8000',
  SOCKET_URL: import.meta.env.VITE_SOCKET_URL || 'http://localhost:8000',

  // File Upload Limits
  MAX_FILE_SIZE: 10 * 1024 * 1024, // 10MB
  MAX_IMAGE_SIZE: 5 * 1024 * 1024, // 5MB
  MAX_VIDEO_SIZE: 50 * 1024 * 1024, // 50MB

  ALLOWED_IMAGE_TYPES: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
  ALLOWED_VIDEO_TYPES: ['video/mp4', 'video/webm'],
  ALLOWED_FILE_TYPES: [
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  ],

  // Cloudinary (for media upload)
  CLOUDINARY_CLOUD_NAME: import.meta.env.VITE_CLOUDINARY_CLOUD_NAME,
  CLOUDINARY_UPLOAD_PRESET: import.meta.env.VITE_CLOUDINARY_UPLOAD_PRESET || 'chat_app',

  // UI Settings
  DESKTOP_BREAKPOINT: 1024,
  TABLET_BREAKPOINT: 768,
  MOBILE_BREAKPOINT: 640,

  // Pagination
  DEFAULT_PAGE_SIZE: 20,
  MESSAGES_PER_PAGE: 50,

  // Timeouts
  REQUEST_TIMEOUT: 30000, // 30 seconds
  DEBOUNCE_DELAY: 300, // 300ms

  // Status/Story
  STATUS_EXPIRE_HOURS: 24,
} as const;

================================================
FILE: src/shared/constants/route-paths.ts
================================================

// ================================================
// FILE: src/shared/constants/route-paths.ts
// Frontend Route Paths (WITH ACTIVE_CALL)
// ================================================

export const ROUTE_PATHS = {
  // Public Routes
  HOME: '/',
  LOGIN: '/auth/login',
  REGISTER: '/auth/register',

  // Protected Routes
  CHATS: '/chats',
  CHAT_DETAIL: '/chats/:chatId',

  STATUS: '/status',

  CALLS: '/calls',
  CALL_HISTORY: '/calls/history',
  ACTIVE_CALL: '/calls/active', // ‚úÖ ADD

  CONTACTS: '/contacts',

  MEDIA: '/media',

  PROFILE: '/profile',

  FRIEND_REQUESTS: '/friend-requests',

  // Settings
  SETTINGS: '/settings',
  SETTINGS_PRIVACY: '/settings/privacy',
  SETTINGS_NOTIFICATIONS: '/settings/notifications',
  SETTINGS_SESSIONS: '/settings/sessions',
} as const;

// Helper to build dynamic routes
export const buildRoute = {
  chatDetail: (chatId: string) => `/chats/${chatId}`,
  userProfile: (userId: string) => `/profile/${userId}`,
} as const;

================================================
FILE: src/shared/constants/socket-events.ts
================================================

// ================================================
// FILE: src/shared/constants/socket-events.ts
// Socket.IO Event Names (UPDATED WITH WEBRTC)
// ================================================

export const SOCKET_EVENTS = {
  // Connection
  CONNECT: 'connect',
  DISCONNECT: 'disconnect',
  CONNECT_ERROR: 'connect_error',

  // User Status
  USER_ONLINE: 'user:online',
  USER_OFFLINE: 'user:offline',

  // Message
  MESSAGE_SEND: 'message:send',
  MESSAGE_RECEIVE: 'message:receive',
  MESSAGE_READ: 'message:read',
  MESSAGE_EDITED: 'message:edited',
  MESSAGE_DELETED: 'message:deleted',

  // Typing
  TYPING_START: 'typing:start',
  TYPING_STOP: 'typing:stop',

  // Call
  CALL_INCOMING: 'call:incoming',
  CALL_ANSWERED: 'call:answered',
  CALL_REJECTED: 'call:rejected',
  CALL_ENDED: 'call:ended',

  // WebRTC Signaling
  WEBRTC_OFFER: 'webrtc:offer',
  WEBRTC_ANSWER: 'webrtc:answer',
  WEBRTC_ICE: 'webrtc:ice',

  // Status
  STATUS_NEW: 'status:new',
  STATUS_VIEWED: 'status:viewed',
  STATUS_EXPIRED: 'status:expired',

  // Friend Request
  FRIEND_REQUEST_RECEIVED: 'friend-request:received',
  FRIEND_REQUEST_ACCEPTED: 'friend-request:accepted',
  FRIEND_REQUEST_REJECTED: 'friend-request:rejected',
} as const;

================================================
FILE: src/shared/hooks/index.ts
================================================

// ================================================
// FILE: src/shared/hooks/index.ts
// Export shared hooks
// ================================================

export { useMediaQuery } from './use-media-query';

================================================
FILE: src/shared/hooks/use-media-query.ts
================================================

// ================================================
// FILE: src/shared/hooks/use-media-query.ts
// useMediaQuery Hook - Detect screen size
// ================================================

import { useState, useEffect } from 'react';

export const useMediaQuery = (query: string): boolean => {
  const [matches, setMatches] = useState(false);

  useEffect(() => {
    const media = window.matchMedia(query);

    // Set initial value
    setMatches(media.matches);

    // Listen for changes
    const listener = (event: MediaQueryListEvent) => {
      setMatches(event.matches);
    };

    // Modern browsers
    if (media.addEventListener) {
      media.addEventListener('change', listener);
      return () => media.removeEventListener('change', listener);
    }
    // Fallback for older browsers
    else {
      media.addListener(listener);
      return () => media.removeListener(listener);
    }
  }, [query]);

  return matches;
};

================================================
FILE: src/shared/types/api-types.ts
================================================

// ================================================
// FILE: src/shared/types/api-types.ts
// API Response Types
// ================================================

// Standard API Response
export interface ApiResponse<T = any> {
  statusCode: number;
  message: string;
  data?: T;
  error?: string;
}

// Success Response
export interface SuccessResponse<T = any> {
  statusCode: number;
  message: string;
  data: T;
}

// Error Response
export interface ErrorResponse {
  statusCode: number;
  message: string;
  error: string;
  details?: any;
}

// Form Error
export interface FormError {
  field: string;
  message: string;
}

// Validation Error
export interface ValidationError {
  errors: FormError[];
}

================================================
FILE: src/shared/types/common-types.ts
================================================

// ================================================
// FILE: src/shared/types/common-types.ts
// Common Shared Types
// ================================================

// Base Entity
export interface BaseEntity {
  id: string;
  createdAt: string;
  updatedAt: string;
}

// Pagination
export interface PaginationParams {
  page: number;
  limit: number;
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// Filter & Sort
export interface FilterParams {
  search?: string;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

// Upload Progress
export interface UploadProgress {
  id: string;
  file: File;
  progress: number;
  status: 'uploading' | 'success' | 'error';
  url?: string;
  error?: string;
}

================================================
FILE: src/shared/types/enum-types.ts
================================================

// ================================================
// FILE: src/shared/types/enum-types.ts
// Common Enums
// ================================================

export enum RequestStatus {
  IDLE = 'idle',
  LOADING = 'loading',
  SUCCESS = 'success',
  ERROR = 'error',
}

export enum PrivacyLevel {
  PUBLIC = 'PUBLIC',
  FRIENDS = 'FRIENDS',
  PRIVATE = 'PRIVATE',
}

export enum NotificationType {
  MESSAGE = 'MESSAGE',
  CALL = 'CALL',
  FRIEND_REQUEST = 'FRIEND_REQUEST',
  MENTION = 'MENTION',
  SYSTEM = 'SYSTEM',
}

================================================
FILE: src/shared/types/media-types.ts
================================================

// ================================================
// FILE: src/shared/types/media-types.ts
// Media Related Types
// ================================================

export enum MediaType {
  IMAGE = 'image',
  VIDEO = 'video',
  AUDIO = 'audio',
  FILE = 'file',
}

export interface MediaItem {
  id: string;
  userId: string;
  filename: string;
  originalName: string;
  mimeType: string;
  size: number;
  url: string;
  thumbnailUrl: string | null;
  width: number | null;
  height: number | null;
  duration: number | null;
  createdAt: string;
  updatedAt: string;
}

================================================
FILE: src/shared/types/socket-types.ts
================================================

// ================================================
// FILE: src/shared/types/socket-types.ts
// Socket Event Types
// ================================================

export interface SocketConnectPayload {
  userId: string;
  socketId: string;
}

export interface SocketDisconnectPayload {
  userId: string;
  reason: string;
}

export interface TypingPayload {
  userId: string;
  chatId: string;
  username: string;
}

================================================
FILE: src/shared/types/ui-types.ts
================================================

// ================================================
// FILE: src/shared/types/ui-types.ts
// UI Component Types
// ================================================

export type ButtonVariant = 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
export type ButtonSize = 'default' | 'sm' | 'lg' | 'icon';

export type AlertVariant = 'default' | 'destructive';

export type ToastVariant = 'default' | 'success' | 'error' | 'warning' | 'info';

export interface ToastOptions {
  title?: string;
  description?: string;
  duration?: number;
  variant?: ToastVariant;
}

export interface DialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  title: string;
  description?: string;
}

export interface ModalProps extends DialogProps {
  size?: 'sm' | 'md' | 'lg' | 'xl';
  showCloseButton?: boolean;
}


================================================
FILE: src/shared/types/user-types.ts
================================================

// ================================================
// FILE: src/shared/types/user-types.ts
// User Related Types
// ================================================

export enum Gender {
  MALE = 'MALE',
  FEMALE = 'FEMALE',
  OTHER = 'OTHER',
  PREFER_NOT_TO_SAY = 'PREFER_NOT_TO_SAY',
}

export interface User {
  id: string;
  name: string;
  email: string;
  username: string | null;
  avatar: string | null;
  about: string | null;
  gender: Gender | null;
  profilePhoto: string | null;
  lastSeen: string | null;
  isOnline: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface UserPreview {
  id: string;
  name: string;
  avatar: string | null;
  username: string | null;
}

================================================
FILE: src/shared/utils/cn.ts
================================================

// ================================================
// FILE: src/shared/utils/cn.ts
// Tailwind Class Merge Utility
// ================================================

import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}


================================================
FILE: src/shared/utils/date-formatter.ts
================================================

// ================================================
// FILE: src/shared/utils/date-formatter.ts
// Date Formatting Utilities
// ================================================

import { format, isToday, isYesterday, isThisWeek } from 'date-fns';

export const dateFormatter = {
  // Format for message time (e.g., "14:30" or "Yesterday")
  messageTime(dateString: string): string {
    const date = new Date(dateString);

    if (isToday(date)) {
      return format(date, 'HH:mm');
    }

    if (isYesterday(date)) {
      return 'Yesterday';
    }

    if (isThisWeek(date)) {
      return format(date, 'EEEE');
    }

    return format(date, 'dd/MM/yyyy');
  },

  // Format for chat list (e.g., "14:30" or "01/12")
  chatListTime(dateString: string): string {
    const date = new Date(dateString);

    if (isToday(date)) {
      return format(date, 'HH:mm');
    }

    if (isYesterday(date)) {
      return 'Yesterday';
    }

    return format(date, 'dd/MM/yy');
  },

  // Format for call duration (e.g., "2m 30s")
  callDuration(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;

    if (mins === 0) {
      return `${secs}s`;
    }

    return `${mins}m ${secs}s`;
  },

  // Format for relative time (e.g., "2 hours ago")
  relativeTime(dateString: string): string {
    const date = new Date(dateString);
    const now = new Date();
    const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

    if (diffInSeconds < 60) {
      return 'Just now';
    }

    const diffInMinutes = Math.floor(diffInSeconds / 60);
    if (diffInMinutes < 60) {
      return `${diffInMinutes}m ago`;
    }

    const diffInHours = Math.floor(diffInMinutes / 60);
    if (diffInHours < 24) {
      return `${diffInHours}h ago`;
    }

    const diffInDays = Math.floor(diffInHours / 24);
    if (diffInDays < 7) {
      return `${diffInDays}d ago`;
    }

    return format(date, 'dd/MM/yyyy');
  },

  // Format full date time (e.g., "January 1, 2024 14:30")
  fullDateTime(dateString: string): string {
    return format(new Date(dateString), 'PPp');
  },
};

================================================
FILE: src/shared/utils/error-handler.ts
================================================

// ================================================
// FILE: src/shared/utils/error-handler.ts
// Centralized Error Handler with Toast
// ================================================

import { toastHelper } from './toast-helper';
import { AxiosError } from 'axios';

/**
 * Handle API errors with appropriate toast messages
 */
export function handleApiError(error: any, fallbackMessage = 'Something went wrong') {
  // Check if it's an Axios error
  if (error.response) {
    const status = error.response.status;
    const message = error.response.data?.message || error.message;

    switch (status) {
      case 400:
        toastHelper.error(message || 'Bad request');
        break;

      case 401:
        toastHelper.error('Session expired. Please login again');
        // Optionally redirect to login
        setTimeout(() => {
          window.location.href = '/auth/login';
        }, 2000);
        break;

      case 403:
        toastHelper.error('You don\'t have permission to do this');
        break;

      case 404:
        toastHelper.error('Resource not found');
        break;

      case 409:
        toastHelper.error(message || 'Conflict: Resource already exists');
        break;

      case 422:
        toastHelper.error(message || 'Validation failed');
        break;

      case 429:
        toastHelper.error('Too many requests. Please try again later');
        break;

      case 500:
      case 502:
      case 503:
        toastHelper.error('Server error. Please try again later');
        break;

      default:
        toastHelper.error(message || fallbackMessage);
    }
  } else if (error.request) {
    // Network error
    toastHelper.error('Network error. Please check your connection');
  } else {
    // Other errors
    toastHelper.error(error.message || fallbackMessage);
  }
}

/**
 * Extract error message from various error formats
 */
export function getErrorMessage(error: any, fallback = 'An error occurred'): string {
  if (typeof error === 'string') {
    return error;
  }

  if (error?.response?.data?.message) {
    return error.response.data.message;
  }

  if (error?.message) {
    return error.message;
  }

  return fallback;
}

================================================
FILE: src/shared/utils/file-helper.ts
================================================

// ================================================
// FILE: src/shared/utils/file-helper.ts
// File Validation & Upload Helpers
// ================================================

import { APP_CONFIG } from '@/shared/constants/app-config';

export const fileHelper = {
  // Validate file size
  validateSize(file: File, maxSize: number = APP_CONFIG.MAX_FILE_SIZE): boolean {
    return file.size <= maxSize;
  },

  // Validate file type
  validateType(file: File, allowedTypes: string[]): boolean {
    return allowedTypes.includes(file.type);
  },

  // Check if file is image
  isImage(file: File): boolean {
    return file.type.startsWith('image/');
  },

  // Check if file is video
  isVideo(file: File): boolean {
    return file.type.startsWith('video/');
  },

  // Format file size (e.g., "1.5 MB")
  formatSize(bytes: number): string {
    if (bytes === 0) return '0 Bytes';

    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return `${Math.round(bytes / Math.pow(k, i) * 100) / 100} ${sizes[i]}`;
  },

  // Get file extension
  getExtension(filename: string): string {
    return filename.slice(filename.lastIndexOf('.') + 1).toLowerCase();
  },

  // Create file preview URL
  createPreviewUrl(file: File): string {
    return URL.createObjectURL(file);
  },

  // Revoke preview URL
  revokePreviewUrl(url: string): void {
    URL.revokeObjectURL(url);
  },

  // Validate image file
  validateImage(file: File): { valid: boolean; error?: string } {
    if (!this.isImage(file)) {
      return { valid: false, error: 'File must be an image' };
    }

    if (!this.validateType(file, APP_CONFIG.ALLOWED_IMAGE_TYPES)) {
      return { valid: false, error: 'Invalid image format' };
    }

    if (!this.validateSize(file, APP_CONFIG.MAX_IMAGE_SIZE)) {
      return {
        valid: false,
        error: `Image size must be less than ${this.formatSize(APP_CONFIG.MAX_IMAGE_SIZE)}`
      };
    }

    return { valid: true };
  },

  // Validate video file
  validateVideo(file: File): { valid: boolean; error?: string } {
    if (!this.isVideo(file)) {
      return { valid: false, error: 'File must be a video' };
    }

    if (!this.validateType(file, APP_CONFIG.ALLOWED_VIDEO_TYPES)) {
      return { valid: false, error: 'Invalid video format' };
    }

    if (!this.validateSize(file, APP_CONFIG.MAX_VIDEO_SIZE)) {
      return {
        valid: false,
        error: `Video size must be less than ${this.formatSize(APP_CONFIG.MAX_VIDEO_SIZE)}`
      };
    }

    return { valid: true };
  },
};

================================================
FILE: src/shared/utils/logger.ts
================================================

// ================================================
// FILE: src/shared/utils/logger.ts
// Development Mode Logger - Auto-hide logs in production
// ================================================

const isDev = import.meta.env.DEV;

export const logger = {
  /**
   * Debug logs - Only visible in development
   */
  debug: (...args: any[]) => {
    if (isDev) {
      console.log('üîç', ...args);
    }
  },

  /**
   * Info logs - Only visible in development
   */
  info: (...args: any[]) => {
    if (isDev) {
      console.info('‚ÑπÔ∏è', ...args);
    }
  },

  /**
   * Warning logs - Only visible in development
   */
  warn: (...args: any[]) => {
    if (isDev) {
      console.warn('‚ö†Ô∏è', ...args);
    }
  },

  /**
   * Error logs - ALWAYS visible (even in production)
   */
  error: (...args: any[]) => {
    console.error('‚ùå', ...args);
  },

  /**
   * Success logs - Only visible in development
   */
  success: (...args: any[]) => {
    if (isDev) {
      console.log('‚úÖ', ...args);
    }
  },

  /**
   * API Request logs - Only visible in development
   */
  apiRequest: (method: string, url: string, data?: any) => {
    if (isDev) {
      console.log('üì§ API Request:', { method, url, data });
    }
  },

  /**
   * API Response logs - Only visible in development
   */
  apiResponse: (url: string, status: number, data?: any) => {
    if (isDev) {
      console.log('‚úÖ API Response:', { url, status, data });
    }
  },

  /**
   * Socket logs - Only visible in development
   */
  socket: (event: string, data?: any) => {
    if (isDev) {
      console.log('üîå Socket:', event, data);
    }
  },
};

================================================
FILE: src/shared/utils/string-helper.ts
================================================

// ================================================
// FILE: src/shared/utils/string-helper.ts
// String Manipulation Helpers
// ================================================

export const stringHelper = {
  // Truncate text
  truncate(text: string, maxLength: number, suffix: string = '...'): string {
    if (text.length <= maxLength) return text;
    return text.slice(0, maxLength - suffix.length) + suffix;
  },

  // Get initials from name
  getInitials(name: string, maxChars: number = 2): string {
    return name
      .split(' ')
      .map(word => word[0])
      .join('')
      .toUpperCase()
      .slice(0, maxChars);
  },

  // Capitalize first letter
  capitalize(text: string): string {
    return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();
  },

  // Convert to title case
  toTitleCase(text: string): string {
    return text
      .toLowerCase()
      .split(' ')
      .map(word => this.capitalize(word))
      .join(' ');
  },

  // Remove special characters
  removeSpecialChars(text: string): string {
    return text.replace(/[^a-zA-Z0-9\s]/g, '');
  },

  // Generate random string
  randomString(length: number = 10): string {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  },
};

================================================
FILE: src/shared/utils/toast-helper.ts
================================================

// ================================================
// FILE: src/shared/utils/toast-helper.ts
// Toast Helper with Rate Limiting
// ================================================

import { toast } from 'sonner';

// Rate limiting: Prevent toast spam
const toastQueue = new Map<string, number>();
const DEFAULT_THROTTLE_DELAY = 2000; // 2 seconds

/**
 * Check if toast should be throttled
 */
function shouldThrottle(key: string, delay: number = DEFAULT_THROTTLE_DELAY): boolean {
  const lastShown = toastQueue.get(key);
  const now = Date.now();

  if (lastShown && now - lastShown < delay) {
    return true; // Throttle this toast
  }

  toastQueue.set(key, now);
  return false;
}

export const toastHelper = {
  /**
   * Success toast
   */
  success: (message: string, key?: string) => {
    if (key && shouldThrottle(key)) return;

    toast.success(message, {
      duration: 3000,
    });
  },

  /**
   * Error toast
   */
  error: (message: string, key?: string) => {
    if (key && shouldThrottle(key)) return;

    toast.error(message, {
      duration: 4000,
    });
  },

  /**
   * Info toast
   */
  info: (message: string, key?: string) => {
    if (key && shouldThrottle(key)) return;

    toast.info(message, {
      duration: 3000,
    });
  },

  /**
   * Warning toast
   */
  warning: (message: string, key?: string) => {
    if (key && shouldThrottle(key)) return;

    toast.warning(message, {
      duration: 3000,
    });
  },

  /**
   * Loading toast - Returns toast ID for dismissal
   */
  loading: (message: string) => {
    return toast.loading(message);
  },

  /**
   * Dismiss specific toast
   */
  dismiss: (toastId: string | number) => {
    toast.dismiss(toastId);
  },

  /**
   * Dismiss all toasts
   */
  dismissAll: () => {
    toast.dismiss();
  },

  /**
   * Promise toast - Auto handles loading/success/error
   */
  promise: <T>(
    promise: Promise<T>,
    messages: {
      loading: string;
      success: string;
      error: string;
    }
  ) => {
    return toast.promise(promise, messages);
  },
};

================================================
FILE: src/shared/utils/validation.ts
================================================

// ================================================
// FILE: src/shared/utils/validation.ts
// Form Validation Helpers
// ================================================

export const validation = {
  // Email validation
  email(value: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(value);
  },

  // Password validation (min 6 chars)
  password(value: string, minLength: number = 6): boolean {
    return value.length >= minLength;
  },

  // Username validation (alphanumeric + underscore)
  username(value: string): boolean {
    const usernameRegex = /^[a-zA-Z0-9_]{3,20}$/;
    return usernameRegex.test(value);
  },

  // Phone number validation
  phone(value: string): boolean {
    const phoneRegex = /^[+]?[(]?[0-9]{3}[)]?[-\s.]?[0-9]{3}[-\s.]?[0-9]{4,6}$/;
    return phoneRegex.test(value);
  },

  // URL validation
  url(value: string): boolean {
    try {
      new URL(value);
      return true;
    } catch {
      return false;
    }
  },

  // Required field
  required(value: any): boolean {
    if (typeof value === 'string') {
      return value.trim().length > 0;
    }
    return value !== null && value !== undefined;
  },

  // Min length
  minLength(value: string, min: number): boolean {
    return value.length >= min;
  },

  // Max length
  maxLength(value: string, max: number): boolean {
    return value.length <= max;
  },
};


================================================
FILE: src/store/index.ts
================================================


// ================================================
// FILE: src/store/index.ts
// Central export for all stores
// ================================================

// Auth Store
export { useAuthStore } from '@/features/auth/store/auth.store';

// Chat Store
export { useChatStore } from '@/features/chat/store/chat.store';

// Call Store
export { useCallStore } from '@/features/call/store/call.store';

// Contact Store
export { useContactStore } from '@/features/contacts/store/contact.store';

// Status Store
export { useStatusStore } from '@/features/status/store/status.store';

// Profile Store
export { useProfileStore } from '@/features/profile/store/profile.store';

================================================
FILE: src/types/index.ts
================================================

// ================================================
// FILE: src/types/index.ts
// Central export for all types
// ================================================

// Auth Types
export type {
  LoginInput,
  RegisterInput,
  AuthResponse,
  AuthState,
} from '@/features/auth/types/auth.types';

// Chat Types
export type {
  Chat,
  ChatWithDetails,
  Message,
  MessageWithDetails,
  MessageType,
  CreateChatInput,
  CreateMessageInput,
  TypingIndicator,
} from '@/features/chat/types/chat.types';

// Call Types
export type {
  Call,
  CallWithDetails,
  InitiateCallInput,
  WebRTCSignal,
} from '@/features/call/types/call.types';

export { CallType, CallStatus } from '@/features/call/types/call.types';

// Contact Types
export type {
  Contact,
  ContactWithDetails,
  FriendRequest,
  FriendRequestWithDetails,
  SendRequestInput,
  BlockContactInput,
  UpdateNicknameInput,
  FriendStatus,
} from '@/features/contacts/types/contact.types';

export { RequestStatus } from '@/features/contacts/types/contact.types';

// Status Types
export type {
  Status,
  StatusWithDetails,
  StatusPrivacy,
  StatusView,
  CreateStatusInput,
  UpdateStatusPrivacyInput,
} from '@/features/status/types/status.types';

export { StatusType, StatusPrivacyType } from '@/features/status/types/status.types';

// Media Types
export type {
  UploadMediaInput,
  CloudinaryUploadResult,
  UploadProgress,
} from '@/features/media/types/media.types';

// Profile Types
export type {
  UpdateProfileInput,
  ChangePasswordInput,
  UpdatePrivacyInput,
  UserSettings,
  Session,
} from '@/features/profile/types/profile.types';

export {
  LastSeenPrivacy,
  ProfilePhotoPrivacy,
  AboutPrivacy,
} from '@/features/profile/types/profile.types';

// Re-export shared types
export type {
  User,
  UserPreview,
  Gender,
} from '@/shared/types/user-types';

export type {
  ApiResponse,
  SuccessResponse,
  ErrorResponse,
  FormError,
  ValidationError,
} from '@/shared/types/api-types';

export type {
  MediaItem,
  MediaType,
} from '@/shared/types/media-types';

export type {
  BaseEntity,
  PaginationParams,
  PaginatedResponse,
} from '@/shared/types/common-types';

================================================
FILE: package.json
================================================

{
  "name": "web",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.2.2",
    "@radix-ui/react-avatar": "^1.1.11",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-switch": "^1.2.6",
    "@radix-ui/react-tabs": "^1.1.13",
    "@tanstack/react-query": "^5.90.11",
    "axios": "^1.13.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cookie-parser": "^1.4.7",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.555.0",
    "next-themes": "^0.4.6",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-hook-form": "^7.67.0",
    "react-router-dom": "^7.10.0",
    "socket.io-client": "^4.8.1",
    "sonner": "^2.0.7",
    "tailwind-merge": "^3.4.0",
    "zod": "^4.1.13",
    "zustand": "^5.0.9"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@tailwindcss/postcss": "^4.1.17",
    "@types/cookie-parser": "^1.4.10",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.22",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.5.6",
    "tailwindcss": "3.4.17",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}


================================================
FILE: tsconfig.json
================================================

{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": [
      "ES2020",
      "DOM",
      "DOM.Iterable"
    ],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": false,
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./src/*"
      ],
      "@/components/*": [
        "./src/shared/components/*"
      ],
      "@/features/*": [
        "./src/features/*"
      ],
      "@/shared/*": [
        "./src/shared/*"
      ],
      "@/lib/*": [
        "./src/lib/*"
      ]
    }
  },
  "include": [
    "src"
  ],
  "references": [
    {
      "path": "./tsconfig.node.json"
    }
  ]
}

================================================
FILE: tsconfig.node.json
================================================

{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "emitDeclarationOnly": true
  },
  "include": [
    "vite.config.ts"
  ]
}

================================================
FILE: vite.config.ts
================================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@/components': path.resolve(__dirname, './src/shared/components'),
      '@/features': path.resolve(__dirname, './src/features'),
      '@/shared': path.resolve(__dirname, './src/shared'),
      '@/lib': path.resolve(__dirname, './src/lib'),
    },
  },
  server: {
    port: 5173,  // ‚Üê UBAH JADI 5173
    host: true,
    open: true,
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
  },
})

================================================
FILE: tailwind.config.js
================================================

/** @type {import('tailwindcss').Config} */
export default {
  darkMode: ['class'],
  content: [
    './index.html',
    './src/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    container: {
      center: true,
      padding: '2rem',
      screens: {
        '2xl': '1400px',
      },
    },
    extend: {
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      keyframes: {
        'accordion-down': {
          from: { height: '0' },
          to: { height: 'var(--radix-accordion-content-height)' },
        },
        'accordion-up': {
          from: { height: 'var(--radix-accordion-content-height)' },
          to: { height: '0' },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
}

================================================
FILE: eslint.config.js
================================================

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default [
  {
    ignores: ['dist']
  },
  {
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: {
        ...globals.browser,
        // WebRTC Types
        RTCPeerConnection: 'readonly',
        RTCSessionDescription: 'readonly',
        RTCIceCandidate: 'readonly',
        RTCSessionDescriptionInit: 'readonly',
        RTCIceCandidateInit: 'readonly',
        MediaStream: 'readonly',
        navigator: 'readonly',
      },
      parser: tseslint.parser,
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
      },
    },
    plugins: {
      '@typescript-eslint': tseslint.plugin,
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...tseslint.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,

      // Nonaktifkan error untuk any type
      '@typescript-eslint/no-explicit-any': 'off',

      // Nonaktifkan error untuk unused variables
      '@typescript-eslint/no-unused-vars': 'off',
      'no-unused-vars': 'off',

      // Nonaktifkan error untuk undefined variables (RTCSessionDescriptionInit, dll)
      'no-undef': 'off',

      // Nonaktifkan react-refresh warnings
      'react-refresh/only-export-components': 'off',

      // Nonaktifkan semua react-hooks warnings
      'react-hooks/exhaustive-deps': 'off',
      'react-hooks/immutability': 'off',
      'react-hooks/set-state-in-effect': 'off',
    },
  },
]

================================================
FILE: components.json
================================================

{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}


================================================
FILE: .env.example
================================================

# API Configuration
VITE_API_URL=http://localhost:8000
VITE_SOCKET_URL=http://localhost:8000

# Cloudinary (for media upload)
VITE_CLOUDINARY_CLOUD_NAME=your_cloud_name
VITE_CLOUDINARY_UPLOAD_PRESET=chat_app

# App Configuration
VITE_APP_NAME=Chat App Pro
VITE_APP_VERSION=1.0.0

================================================
FILE: index.html
================================================

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Chat App Pro - Real-time messaging application" />
    <title>Chat App Pro</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================================================
COLLECTION SUMMARY
================================================
Total files collected: 125
Total folders skipped: 4
Completed at: Wed, Dec 10, 2025  9:08:30 AM
================================================
